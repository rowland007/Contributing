{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Contributing to Projects Pull requests , bug reports , and questions are always welcome. If you feel like contributing financially, please see my donation page. See each projects build page on how to build the specific project The Contributing specifies how to use Git and Github with the projects The Code Style Guide shows how to import files, use classes, methods, and variable names","title":"Home"},{"location":"#contributing-to-projects","text":"Pull requests , bug reports , and questions are always welcome. If you feel like contributing financially, please see my donation page. See each projects build page on how to build the specific project The Contributing specifies how to use Git and Github with the projects The Code Style Guide shows how to import files, use classes, methods, and variable names","title":"Contributing to Projects"},{"location":"contribute/","text":"Introduction Want to contribute to my project but never used git before? Maybe you just need a refresher? Or if you just want to know how I would like my projects done? This guide is for you! Requirement All contributions to the source code must be cryptographically signed by the author\u2019s PGP key or GitHub's key. Notice This page is always a work in progress. It gets updated when I learn new tricks or when there's a more secure way of doing things. If you notice any errors or have trouble with a way I am doing things, please feel free to contact me via my website: randyrowland.me . You may also create a pull request for this guide. Be sure to checkout the Style Guide to save yourself headaches during a pull request. Table of Contents Forking the Project Branches Code Signing (External Website) Committing Pull Request Bug Reports","title":"Introduction"},{"location":"contribute/#introduction","text":"Want to contribute to my project but never used git before? Maybe you just need a refresher? Or if you just want to know how I would like my projects done? This guide is for you! Requirement All contributions to the source code must be cryptographically signed by the author\u2019s PGP key or GitHub's key.","title":"Introduction"},{"location":"contribute/#notice","text":"This page is always a work in progress. It gets updated when I learn new tricks or when there's a more secure way of doing things. If you notice any errors or have trouble with a way I am doing things, please feel free to contact me via my website: randyrowland.me . You may also create a pull request for this guide. Be sure to checkout the Style Guide to save yourself headaches during a pull request.","title":"Notice"},{"location":"contribute/#table-of-contents","text":"Forking the Project Branches Code Signing (External Website) Committing Pull Request Bug Reports","title":"Table of Contents"},{"location":"contribute/branch/","text":"Organizing Repos with Branches At the core, the central repo holds two main branches with an infinite lifetime and possibly several supporting branches that only last for a specific purpose. The Main Branches master develop We consider origin/master to be the main branch where the source code always reflects a production-ready state. It will always compile, should have most if not all known bugs removed, and function as intended. We consider origin/develop to be the main branch where the source code reflects a state with the latest delivered development changes for the next release . This is where the code will always compile but runtime errors or bugs might exist and are discovered. The supporting branches are created from the develop branch to either add features, fix bugs, or specialized release branches. Your changes should be made in your own branch supporting branch from the develop branch and your pull request will be made into the develop branch. More of that will be covered in the Pull Request section. Supporting Branches There are several different types of branches with their own unique uses. Below are a few of the most common ones but they may be more: Feature branches Release branches Hotfix branches GitHub Pages branch Docs branch Each of these branches have a specific purpose and are bound to strict rules as to which branches may be their originating branch and which branches must be their merge targets. We will walk through them in a minute. Info By no means are these branches \u201cspecial\u201d from a technical perspective. The branch types are categorized by how we use them. They are of course plain old Git branches. Feature Branches May branch off from: develop Must merge back into: develop Branch naming convention: anything except master , develop , release-* , or hotfix-* Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment). Info Feature branches typically exist in developer repos only (aka fork / downstream ), not in origin. Finished features may be merged into the develop branch to definitely add them to the upcoming release. The --no-ff flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature. Compare: More than likely this will be the type of branch you'll work with most often. Although, you can use any name you'd like, I suggest you make the branch informative. As in you can tell why the branch was created by its name. You may use the feature/ prefix. Release Branches May branch off from: develop Must merge back into: develop and master Branch naming convention: release/* Release branches support preparation of a new production release. They allow for last-minute dotting of i\u2019s and crossing t\u2019s. Furthermore, they allow for minor bug fixes and preparing meta-data for a release (version number, build dates, etc.). By doing all of this work on a release branch, the develop branch is cleared to receive features for the next big release. The key moment to branch off a new release branch from develop is when develop (almost) reflects the desired state of the new release. At least all features that are targeted for the release-to-be-built must be merged in to develop at this point in time. All features targeted at future releases may not\u2014they must wait until after the release branch is branched off. It is exactly at the start of a release branch that the upcoming release gets assigned a version number\u2014not any earlier. Up until that moment, the develop branch reflected changes for the \u201cnext release\u201d, but it is unclear whether that \u201cnext release\u201d will eventually become 0.3 or 1.0, until the release branch is started. That decision is made on the start of the release branch and is carried out by the project\u2019s rules on version number bumping. When the state of the release branch is ready to become a real release, some actions need to be carried out. First, the release branch is merged into master (since every commit on master is a new release by definition, remember). Next, that commit on master must be tagged for easy future reference to this historical version. Finally, the changes made on the release branch need to be merged back into develop , so that future releases also contain these bug fixes. git checkout master # Switched to branch 'master' git merge --no-ff release/1.2 # Merge made by recursive. (Summary of changes) git tag -s 1 .2 Hotfix Branches May branch off from: master Must merge back into: develop and master Branch naming convention: hotfix/ Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version. The essence is that work of team members (on the develop branch) can continue, while another person is preparing a quick production fix. Repeat steps above (in release branch) to merge into master and develop but bump the tag version by a minor. git tag -s 1 .2.1 The one exception to the rule here is that, when a release/ branch currently exists, the hotfix changes need to be merged into that release/ branch, instead of develop . Back-merging the hotfix into the release branch will eventually result in the hotfix being merged into develop too, when the release branch is finished. (If work in develop immediately requires this hotfix and cannot wait for the release branch to be finished, you may safely merge the hotfix into develop now already as well.) GitHub Pages Branch These are special branches that are only used with GitHub. This branch is used to display a website about the project. More information can be found on GitHub Pages More than likely this branch will already exist for the project but if you'd like to add one to your own repo, here are the steps. If the branch does not exist: git checkout --orphan gh-pages git reset --hard git commit --allow-empty -s -m \"Initializing gh-pages branch\" git push origin gh-pages Now checkout a branch that will contain the websites source files. For me, I use the docs branch (see below how to create this special branch) and if I am creating a website only without a project, I will use master branch. For this example, I will be using the doc branch. git checkout -B docs You can now initialize your site's static generator if you're using one. I use Hugo and Mkdocs for my pages. Initialization Commands Mkdocs Hugo mkdocs new . hugo new site --force . Tip Add the generated contents folder to the .gitignore file. Mkdocs Hugo echo \"site/\" >> .gitignore echo \"public/\" >> .gitignore Now comes the tricky and confusing part. While remaining on the docs or master branch, you'll checkout the gh-pages branch inside of the public/ or site/ folder. That way when the site is generated, it's already on the gh-pages branch. This keeps the site's source files and the site's generated files separated and in different branches for better readability. The command to be able to checkout another branch to a specific folder is worktree : Checkout a branch to a specific folder Mkdocs Hugo git worktree add -B gh-pages site origin/gh-pages git worktree add -B gh-pages public origin/gh-pages Warning Remember, you run this command from your docs or master branch. Now you can build your content with either hugo or mkdocs build . Now you can run one command to commit your changes and push it to your site for publishing. Mkdocs Hugo cd site && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages cd public && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages Docs Branch I use this branch to hold the source files for my static generator. You create the branch similar to the gh-pages branch. git checkout --orphan docs git reset --hard git commit --allow-empty -s -m \"Initializing docs branch\" git push origin docs You can now initialize your site's static generator if you're using one. I use Hugo and Mkdocs for my pages. Initialization Commands Mkdocs Hugo mkdocs new . hugo new site --force . Don't forget to add the generated contents folder to the .gitignore file. Tip Add the generated contents folder to the .gitignore file. Mkdocs Hugo echo \"site/\" >> .gitignore echo \"public/\" >> .gitignore The command to be able to checkout another branch to a specific folder is worktree : Checkout a branch to a specific folder Mkdocs Hugo git worktree add -B gh-pages site origin/gh-pages git worktree add -B gh-pages public origin/gh-pages Warning Remember, you run this command from your docs or master branch. Also note you do not need the < > it is just there to show you only chose one of the folders depending on your generator's output folder. Now you can build your content with either hugo or mkdocs build . Now you can run one command to commit your changes and push it to your site for publishing. Mkdocs Hugo cd site && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages cd public && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages","title":"Branches"},{"location":"contribute/branch/#organizing-repos-with-branches","text":"At the core, the central repo holds two main branches with an infinite lifetime and possibly several supporting branches that only last for a specific purpose.","title":"Organizing Repos with Branches"},{"location":"contribute/branch/#the-main-branches","text":"master develop We consider origin/master to be the main branch where the source code always reflects a production-ready state. It will always compile, should have most if not all known bugs removed, and function as intended. We consider origin/develop to be the main branch where the source code reflects a state with the latest delivered development changes for the next release . This is where the code will always compile but runtime errors or bugs might exist and are discovered. The supporting branches are created from the develop branch to either add features, fix bugs, or specialized release branches. Your changes should be made in your own branch supporting branch from the develop branch and your pull request will be made into the develop branch. More of that will be covered in the Pull Request section.","title":"The Main Branches"},{"location":"contribute/branch/#supporting-branches","text":"There are several different types of branches with their own unique uses. Below are a few of the most common ones but they may be more: Feature branches Release branches Hotfix branches GitHub Pages branch Docs branch Each of these branches have a specific purpose and are bound to strict rules as to which branches may be their originating branch and which branches must be their merge targets. We will walk through them in a minute. Info By no means are these branches \u201cspecial\u201d from a technical perspective. The branch types are categorized by how we use them. They are of course plain old Git branches.","title":"Supporting Branches"},{"location":"contribute/branch/#feature-branches","text":"May branch off from: develop Must merge back into: develop Branch naming convention: anything except master , develop , release-* , or hotfix-* Feature branches (or sometimes called topic branches) are used to develop new features for the upcoming or a distant future release. When starting development of a feature, the target release in which this feature will be incorporated may well be unknown at that point. The essence of a feature branch is that it exists as long as the feature is in development, but will eventually be merged back into develop (to definitely add the new feature to the upcoming release) or discarded (in case of a disappointing experiment). Info Feature branches typically exist in developer repos only (aka fork / downstream ), not in origin. Finished features may be merged into the develop branch to definitely add them to the upcoming release. The --no-ff flag causes the merge to always create a new commit object, even if the merge could be performed with a fast-forward. This avoids losing information about the historical existence of a feature branch and groups together all commits that together added the feature. Compare: More than likely this will be the type of branch you'll work with most often. Although, you can use any name you'd like, I suggest you make the branch informative. As in you can tell why the branch was created by its name. You may use the feature/ prefix.","title":"Feature Branches"},{"location":"contribute/branch/#release-branches","text":"May branch off from: develop Must merge back into: develop and master Branch naming convention: release/* Release branches support preparation of a new production release. They allow for last-minute dotting of i\u2019s and crossing t\u2019s. Furthermore, they allow for minor bug fixes and preparing meta-data for a release (version number, build dates, etc.). By doing all of this work on a release branch, the develop branch is cleared to receive features for the next big release. The key moment to branch off a new release branch from develop is when develop (almost) reflects the desired state of the new release. At least all features that are targeted for the release-to-be-built must be merged in to develop at this point in time. All features targeted at future releases may not\u2014they must wait until after the release branch is branched off. It is exactly at the start of a release branch that the upcoming release gets assigned a version number\u2014not any earlier. Up until that moment, the develop branch reflected changes for the \u201cnext release\u201d, but it is unclear whether that \u201cnext release\u201d will eventually become 0.3 or 1.0, until the release branch is started. That decision is made on the start of the release branch and is carried out by the project\u2019s rules on version number bumping. When the state of the release branch is ready to become a real release, some actions need to be carried out. First, the release branch is merged into master (since every commit on master is a new release by definition, remember). Next, that commit on master must be tagged for easy future reference to this historical version. Finally, the changes made on the release branch need to be merged back into develop , so that future releases also contain these bug fixes. git checkout master # Switched to branch 'master' git merge --no-ff release/1.2 # Merge made by recursive. (Summary of changes) git tag -s 1 .2","title":"Release Branches"},{"location":"contribute/branch/#hotfix-branches","text":"May branch off from: master Must merge back into: develop and master Branch naming convention: hotfix/ Hotfix branches are very much like release branches in that they are also meant to prepare for a new production release, albeit unplanned. They arise from the necessity to act immediately upon an undesired state of a live production version. When a critical bug in a production version must be resolved immediately, a hotfix branch may be branched off from the corresponding tag on the master branch that marks the production version. The essence is that work of team members (on the develop branch) can continue, while another person is preparing a quick production fix. Repeat steps above (in release branch) to merge into master and develop but bump the tag version by a minor. git tag -s 1 .2.1 The one exception to the rule here is that, when a release/ branch currently exists, the hotfix changes need to be merged into that release/ branch, instead of develop . Back-merging the hotfix into the release branch will eventually result in the hotfix being merged into develop too, when the release branch is finished. (If work in develop immediately requires this hotfix and cannot wait for the release branch to be finished, you may safely merge the hotfix into develop now already as well.)","title":"Hotfix Branches"},{"location":"contribute/branch/#github-pages-branch","text":"These are special branches that are only used with GitHub. This branch is used to display a website about the project. More information can be found on GitHub Pages More than likely this branch will already exist for the project but if you'd like to add one to your own repo, here are the steps. If the branch does not exist: git checkout --orphan gh-pages git reset --hard git commit --allow-empty -s -m \"Initializing gh-pages branch\" git push origin gh-pages Now checkout a branch that will contain the websites source files. For me, I use the docs branch (see below how to create this special branch) and if I am creating a website only without a project, I will use master branch. For this example, I will be using the doc branch. git checkout -B docs You can now initialize your site's static generator if you're using one. I use Hugo and Mkdocs for my pages. Initialization Commands Mkdocs Hugo mkdocs new . hugo new site --force . Tip Add the generated contents folder to the .gitignore file. Mkdocs Hugo echo \"site/\" >> .gitignore echo \"public/\" >> .gitignore Now comes the tricky and confusing part. While remaining on the docs or master branch, you'll checkout the gh-pages branch inside of the public/ or site/ folder. That way when the site is generated, it's already on the gh-pages branch. This keeps the site's source files and the site's generated files separated and in different branches for better readability. The command to be able to checkout another branch to a specific folder is worktree : Checkout a branch to a specific folder Mkdocs Hugo git worktree add -B gh-pages site origin/gh-pages git worktree add -B gh-pages public origin/gh-pages Warning Remember, you run this command from your docs or master branch. Now you can build your content with either hugo or mkdocs build . Now you can run one command to commit your changes and push it to your site for publishing. Mkdocs Hugo cd site && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages cd public && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages","title":"GitHub Pages Branch"},{"location":"contribute/branch/#docs-branch","text":"I use this branch to hold the source files for my static generator. You create the branch similar to the gh-pages branch. git checkout --orphan docs git reset --hard git commit --allow-empty -s -m \"Initializing docs branch\" git push origin docs You can now initialize your site's static generator if you're using one. I use Hugo and Mkdocs for my pages. Initialization Commands Mkdocs Hugo mkdocs new . hugo new site --force . Don't forget to add the generated contents folder to the .gitignore file. Tip Add the generated contents folder to the .gitignore file. Mkdocs Hugo echo \"site/\" >> .gitignore echo \"public/\" >> .gitignore The command to be able to checkout another branch to a specific folder is worktree : Checkout a branch to a specific folder Mkdocs Hugo git worktree add -B gh-pages site origin/gh-pages git worktree add -B gh-pages public origin/gh-pages Warning Remember, you run this command from your docs or master branch. Also note you do not need the < > it is just there to show you only chose one of the folders depending on your generator's output folder. Now you can build your content with either hugo or mkdocs build . Now you can run one command to commit your changes and push it to your site for publishing. Mkdocs Hugo cd site && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages cd public && git add --all && git commit -s -m \"Publishing to gh-pages\" && cd .. git push origin gh-pages","title":"Docs Branch"},{"location":"contribute/bug/","text":"Introduction Submitting quality bug reports is important to get bugs fixed and to not waste developer time. Once a bug is reported, a dev will have to verify that the report is actually a bug. Once it has been verified, a dev has to hunt down the cause of the bug, and then fix it. Key Steps to Submit a Quality Bug Report Check for duplicate issues Strong Title Steps to reproduce the bug Only one issue per ticket Be detailed Give references Attached files when able Expected & Actual Results Duplicate Issues The first step in creating a bug report is to search the bug tracker to see if the bug has already been reported. No need to report it again but if you can provide more information, add to the conversation. Bad Issue #121: Feature Request to Add App to Other App Stores Issue #346: App isn't in F-Droid Issue #987: Please add to iTunes Store & Amazon AppStore Strong Title The title of the bug report is the first thing the reader sees. It should be short and provide a quick summary of the bug. Writing brief titles takes practice. Start by trimming the fat \u2013 leave out unnecessary words and avoid using generic titles such as \u201c____ is not working\u201d. Instead of saying what isn\u2019t happening, say what is happening. Good Login button leads to 404 error Bad Login button is not working A strong title not only helps gain an understanding of what the bug is about, it helps reduce creating duplicate bugs by knowing that the bug already exists in the bug tracking tool. Steps to Reproduce the Bug The body of the bug report should provide more detailed information and should always include the steps to reproduce the bug. Like the title, keep this section concise, but include all necessary details. Listing the steps in a numbered sequence makes it easy to read and comprehend. Remember, each bug takes time to write and work through \u2013 the more lean and powerful the writing of a bug report, the quicker you can work through and resolve each bug. Perquisites can also reduce the number of steps. For example, instead of writing out each step to login, start the steps with \u201c Perquisite: user is logged in \u201d. This section should also include other useful information such as browser type, device, etc. Good Login press the menu button select profile...wait for page to load Click on the \" Dog \" button and you'll see a cat appear Bad Click on the \" Dog \" button and you'll see a cat Only One Issue Please only put one issue in each issue ticket. This allows each separate issues to be worked on individually, and the ticket for each issue closed as it has been worked on. This helps team members, any 3rd party contributors, and also the ticket filer. You can use links and GitHub tools to point to other relevant tickets. Good Login button leads to 404 error Bad Login button leads to 404 error & menu button causes app to freeze after getting logged in Be Detailed Be as detailed as can be in the description; don\u2019t assume familiarity with the issue. Good I am on version 0.1.2 using a Pixel with Android 10. After I logged in and clicked the menu button in the top left, it got stuck halfway. I clicked it again to try to see the whole menu but then the screen turned black and I got \" Error: Bad Device Link \". I restarted the app and it did it again. Bad My menu isn't working and it's annoying. Try to include this like version, component, platform, operation system, and severity. Tip Use @mention individuals that you specifically want to involve in the discussion, and mention why. (\u201c/cc @rowland007 for clarification on this logic\u201d) or @mention teams that you want to involve in the discussion, and mention why. (\u201c/cc @github/security, does CVE-2019XXX effect the repo?\u201d) Give References You can provide links to news articles, CVEs, or guides that may help explain your point or drive a decision. Good The database needs to be redesigned to mitigate security vulnerabilities found in [CVE-2019XXX](#url-to-info) Bad The database needs to be redesigned to mitigate a new found CVE Attachments A picture is worth a thousand words. Take a Screenshot of the instance of failure with proper captioning to highlight the defect. Highlight unexpected error messages with light red color. This draws attention to the required area. If you can't get a picture, submit a log file. The log file will contain basic system information (like operating system) as well as the version of the app that is running. Frequently it also contains stack traces that can be immensely helpful in hunting down a bug. When able, try to provide both. Expected & Actual Results A Bug description is incomplete without the Expected and Actual results. It is necessary to outline what is the outcome of the test and what the user should expect. The reader should know what the correct outcome of the test is. Clearly, mention what happened during the test and what was the outcome. Good I clicked the \" Dog \" button expecting to see a dog appear on my profile. However, the actual result from clicking the \" Dog \" button was a cat showed up on my profile. Bad The button shows a cat. Example Bug Report Example Bug Name: Application crash on clicking the SAVE button while creating a new user. Bug ID: (It will be automatically created by the BUG Tracking tool once you save this bug) Area Path: USERS menu > New Users Build Number: Version Number 5.0.1 Severity: HIGH (High/Medium/Low) or 1 Priority: HIGH (High/Medium/Low) or 1 Reported By: Your Name Reported On: Date Reason: Defect Status: New/Open/Active (Depends on the Tool you are using) Environment: Windows 2003/SQL Server 2005 Description: Application crash on clicking the SAVE button while creating a new user, hence unable to create a new user in the application. Steps To Reproduce: 1) Login into the Application 2) Navigate to the Users Menu > New User 3) Filled all the user information fields 4) Clicked on the \u2018Save' button 5) Seen an error page \u201cORA1090 Exception: Insert values Error\u2026\u201d 6) See the attached logs for more information (Attach more logs related to bug..IF any) 7) And also see the attached screenshot of the error page. Expected Result: On clicking SAVE button, should be prompted to a success message \u201cNew User has been created successfully\u201d. (Attach \u2018application crash' screenshot. IF any) Conclusion Familiarize yourself with the context of the issue and the reasons why it exists. If you disagree strongly, consider giving it a few minutes before responding; think before you react. Avoid using derogatory terms, like \u201cstupid\u201d, when referring to the work someone has produced. Be humble. (\u201cI\u2019m not sure, let\u2019s try\u2026\u201d) Avoid hyperbole. (\u201c NEVER do\u2026\u201d) Aim to develop professional skills, group knowledge and product quality, through group critique. Be aware of negative bias with online communication. (If content is neutral, we assume the tone is negative.) Can you use positive language as opposed to neutral? You may use emoji to clarify tone. GitHub emoji list Emoji Examples Can some one get some on this please? Looks good, let's get this merged! SECURITY ALERT: App is vulnerable to CVE-2019XXX Consider leading with an expression of appreciation, especially when feedback has been mixed. Ask for clarification. (\u201cI don\u2019t understand, can you clarify?\u201d) Offer clarification, explain the decisions you made to reach a solution in question. Try to respond to every comment. Link to any follow up commits, issues or Pull Requests. (\u201cGood call! Done in issue #1682851\u201d) As a last resort, if there is growing confusion or debate, ask yourself if the written word is still the best form of communication. Talk (virtually) face-to-face, then mutually consider posting a follow-up to summarize any offline discussion (useful for others who be following along, now or later).","title":"Bug Reports"},{"location":"contribute/bug/#introduction","text":"Submitting quality bug reports is important to get bugs fixed and to not waste developer time. Once a bug is reported, a dev will have to verify that the report is actually a bug. Once it has been verified, a dev has to hunt down the cause of the bug, and then fix it.","title":"Introduction"},{"location":"contribute/bug/#key-steps-to-submit-a-quality-bug-report","text":"Check for duplicate issues Strong Title Steps to reproduce the bug Only one issue per ticket Be detailed Give references Attached files when able Expected & Actual Results","title":"Key Steps to Submit a Quality Bug Report"},{"location":"contribute/bug/#duplicate-issues","text":"The first step in creating a bug report is to search the bug tracker to see if the bug has already been reported. No need to report it again but if you can provide more information, add to the conversation. Bad Issue #121: Feature Request to Add App to Other App Stores Issue #346: App isn't in F-Droid Issue #987: Please add to iTunes Store & Amazon AppStore","title":"Duplicate Issues"},{"location":"contribute/bug/#strong-title","text":"The title of the bug report is the first thing the reader sees. It should be short and provide a quick summary of the bug. Writing brief titles takes practice. Start by trimming the fat \u2013 leave out unnecessary words and avoid using generic titles such as \u201c____ is not working\u201d. Instead of saying what isn\u2019t happening, say what is happening. Good Login button leads to 404 error Bad Login button is not working A strong title not only helps gain an understanding of what the bug is about, it helps reduce creating duplicate bugs by knowing that the bug already exists in the bug tracking tool.","title":"Strong Title"},{"location":"contribute/bug/#steps-to-reproduce-the-bug","text":"The body of the bug report should provide more detailed information and should always include the steps to reproduce the bug. Like the title, keep this section concise, but include all necessary details. Listing the steps in a numbered sequence makes it easy to read and comprehend. Remember, each bug takes time to write and work through \u2013 the more lean and powerful the writing of a bug report, the quicker you can work through and resolve each bug. Perquisites can also reduce the number of steps. For example, instead of writing out each step to login, start the steps with \u201c Perquisite: user is logged in \u201d. This section should also include other useful information such as browser type, device, etc. Good Login press the menu button select profile...wait for page to load Click on the \" Dog \" button and you'll see a cat appear Bad Click on the \" Dog \" button and you'll see a cat","title":"Steps to Reproduce the Bug"},{"location":"contribute/bug/#only-one-issue","text":"Please only put one issue in each issue ticket. This allows each separate issues to be worked on individually, and the ticket for each issue closed as it has been worked on. This helps team members, any 3rd party contributors, and also the ticket filer. You can use links and GitHub tools to point to other relevant tickets. Good Login button leads to 404 error Bad Login button leads to 404 error & menu button causes app to freeze after getting logged in","title":"Only One Issue"},{"location":"contribute/bug/#be-detailed","text":"Be as detailed as can be in the description; don\u2019t assume familiarity with the issue. Good I am on version 0.1.2 using a Pixel with Android 10. After I logged in and clicked the menu button in the top left, it got stuck halfway. I clicked it again to try to see the whole menu but then the screen turned black and I got \" Error: Bad Device Link \". I restarted the app and it did it again. Bad My menu isn't working and it's annoying. Try to include this like version, component, platform, operation system, and severity. Tip Use @mention individuals that you specifically want to involve in the discussion, and mention why. (\u201c/cc @rowland007 for clarification on this logic\u201d) or @mention teams that you want to involve in the discussion, and mention why. (\u201c/cc @github/security, does CVE-2019XXX effect the repo?\u201d)","title":"Be Detailed"},{"location":"contribute/bug/#give-references","text":"You can provide links to news articles, CVEs, or guides that may help explain your point or drive a decision. Good The database needs to be redesigned to mitigate security vulnerabilities found in [CVE-2019XXX](#url-to-info) Bad The database needs to be redesigned to mitigate a new found CVE","title":"Give References"},{"location":"contribute/bug/#attachments","text":"A picture is worth a thousand words. Take a Screenshot of the instance of failure with proper captioning to highlight the defect. Highlight unexpected error messages with light red color. This draws attention to the required area. If you can't get a picture, submit a log file. The log file will contain basic system information (like operating system) as well as the version of the app that is running. Frequently it also contains stack traces that can be immensely helpful in hunting down a bug. When able, try to provide both.","title":"Attachments"},{"location":"contribute/bug/#expected-actual-results","text":"A Bug description is incomplete without the Expected and Actual results. It is necessary to outline what is the outcome of the test and what the user should expect. The reader should know what the correct outcome of the test is. Clearly, mention what happened during the test and what was the outcome. Good I clicked the \" Dog \" button expecting to see a dog appear on my profile. However, the actual result from clicking the \" Dog \" button was a cat showed up on my profile. Bad The button shows a cat.","title":"Expected &amp; Actual Results"},{"location":"contribute/bug/#example-bug-report","text":"Example Bug Name: Application crash on clicking the SAVE button while creating a new user. Bug ID: (It will be automatically created by the BUG Tracking tool once you save this bug) Area Path: USERS menu > New Users Build Number: Version Number 5.0.1 Severity: HIGH (High/Medium/Low) or 1 Priority: HIGH (High/Medium/Low) or 1 Reported By: Your Name Reported On: Date Reason: Defect Status: New/Open/Active (Depends on the Tool you are using) Environment: Windows 2003/SQL Server 2005 Description: Application crash on clicking the SAVE button while creating a new user, hence unable to create a new user in the application. Steps To Reproduce: 1) Login into the Application 2) Navigate to the Users Menu > New User 3) Filled all the user information fields 4) Clicked on the \u2018Save' button 5) Seen an error page \u201cORA1090 Exception: Insert values Error\u2026\u201d 6) See the attached logs for more information (Attach more logs related to bug..IF any) 7) And also see the attached screenshot of the error page. Expected Result: On clicking SAVE button, should be prompted to a success message \u201cNew User has been created successfully\u201d. (Attach \u2018application crash' screenshot. IF any)","title":"Example Bug Report"},{"location":"contribute/bug/#conclusion","text":"Familiarize yourself with the context of the issue and the reasons why it exists. If you disagree strongly, consider giving it a few minutes before responding; think before you react. Avoid using derogatory terms, like \u201cstupid\u201d, when referring to the work someone has produced. Be humble. (\u201cI\u2019m not sure, let\u2019s try\u2026\u201d) Avoid hyperbole. (\u201c NEVER do\u2026\u201d) Aim to develop professional skills, group knowledge and product quality, through group critique. Be aware of negative bias with online communication. (If content is neutral, we assume the tone is negative.) Can you use positive language as opposed to neutral? You may use emoji to clarify tone. GitHub emoji list Emoji Examples Can some one get some on this please? Looks good, let's get this merged! SECURITY ALERT: App is vulnerable to CVE-2019XXX Consider leading with an expression of appreciation, especially when feedback has been mixed. Ask for clarification. (\u201cI don\u2019t understand, can you clarify?\u201d) Offer clarification, explain the decisions you made to reach a solution in question. Try to respond to every comment. Link to any follow up commits, issues or Pull Requests. (\u201cGood call! Done in issue #1682851\u201d) As a last resort, if there is growing confusion or debate, ask yourself if the written word is still the best form of communication. Talk (virtually) face-to-face, then mutually consider posting a follow-up to summarize any offline discussion (useful for others who be following along, now or later).","title":"Conclusion"},{"location":"contribute/commit/","text":"Introduction A project\u2019s long-term success rests (among other things) on its maintainability, and a maintainer has few tools more powerful than his project\u2019s log. It\u2019s worth taking the time to learn how to care for one properly. What may be a hassle at first soon becomes habit, and eventually a source of pride and productivity for all involved. Most programming languages have well-established conventions as to what constitutes idiomatic style, i.e. naming, formatting and so on. There are variations on these conventions, of course, but most developers agree that picking one and sticking to it is far better than the chaos that ensues when everybody does their own thing. Reviewing others\u2019 commits and pull requests becomes something worth doing, and suddenly can be done independently. Understanding why something happened months or years ago becomes not only possible but efficient. Fortunately, there are well-established conventions as to what makes an idiomatic Git commit message. Indeed, many of them are assumed in the way certain Git commands function. There\u2019s nothing you need to re-invent. Just follow the seven rules below and you\u2019re on your way to committing like a pro. Requirement Don't forget to sign your commits with the -s flag. The Seven Rules for Great Git Commit Messages Separate subject from body with a blank line Limit the subject line to 50 characters Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 72 characters Use the body to explain what and why and not the how Example: Summarize changes in around 50 characters or less More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of the commit and the rest of the text as the body. The blank line separating the summary from the body is critical ( unless you omit the body entirely ) ; various tools like 'log' , 'shortlog' and 'rebase' can get confused if you run the two together. Explain the problem that this commit is solving. Focus on why you are making this change as opposed to how ( the code explains that ) . Are there side effects or other un-intuitive consequences of this change? Here is the place to explain them. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary here If you use an issue tracker, put references to them at the bottom, like this: Resolves: #123 See also: #456, #789 Info To read more about the 7 rules, visit Chris Beams How to Write a Git Commit Message article. Git Commit Message Template A commit message template helps you write great commit messages and enforce it across teams. You can save the template somewhere it can be accessed by all projects and saved to your git global configuration. git config --global commit.template ~/.git-commit-template.txt If you want empty commit messages (should be avoided but there might be a reason): git config --global commit.cleanup strip This prevents git from using the template as the commit message. git-commit-template.txt # <type>: (If applied, this commit will...) <subject> (Max 50 char) # |<---- Using a Maximum Of 50 Characters ---->| # Explain why this change is being made # |<---- Try To Limit Each Line to a Maximum Of 72 Characters ---->| # Provide links or keys to any relevant tickets, articles or other resources # Example: Github issue #23 # --- COMMIT END --- # Type: # feat (new feature) # fix (bug fix) # refactor (refactoring production code) # style (formatting, missing semi colons, etc; no code change) # docs (changes to documentation) # test (adding or refactoring tests; no production code change) # chore (updating grunt tasks etc; no production code change) # -------------------- # Remember to # 1. Separate subject from body with a blank line # 2. Limit the subject line to 50 characters # 3. Capitalize the subject line # 4. Do not end the subject line with a period # 5. Use the imperative mood in the subject line # 6. Wrap the body at 72 characters # 7. Use the body to explain what and why and not the how # -------------------- # For more information about this template, check out # https://gist.github.com/adeekshith/cd4c95a064977cdc6c50 Squashing Commits Squash your feature's commits before requesting a pull request into the develop branch. Merging vs Rebase In our project\u2019s Git repository, two branches currently exist: the usual master branch, and a feature branch that we created right after the initial commit. On the master branch, we have italicized the \u2018a\u2019, then bolded the \u2018a\u2019. On our feature branch, we have italicized the \u2018b\u2019, and then bolded the \u2018b\u2019. Merge By merging feature into master, master obtains a new commit\u200a\u2014\u200aa \u201cmerge commit\u201d. All by itself, the merge commit represents every change that has occurred on feature since it branched from master. Clean and simple. The downside of merging? If used too liberally, merge commits can clutter up your Git logs, and make it much more difficult to understand the flow of your project\u2019s history. For collaborative workflows in which other developers (and potentially even project managers/leads or QA) read your project\u2019s Git logs for insight and context, readability is important. To avoid this pitfall, try to use merges purposefully and sparingly. Avoid branching and merging when only making minor tweaks or trivial bug fixes. Use merge for cases where you want a set of commits to stand out. Large refactors and major feature additions are good candidates for separate feature branches that can later be merged into master. As an added bonus, when merges are reserved for these major changes, the merge commits act as milestones that others can use to figure out when these major changes were incorporated into the project. Rebase Let\u2019s rewind, and pretend that we instead wanted to keep working on styling the letter \u2018b\u2019\u200a\u2014\u200amaybe change its size, font, color, etc. We need to get it just right\u200a\u2014\u200athis change affects 50% of our codebase! But before we continue working on our feature branch, we decide we want to bring in the latest changes from master to keep things fresh. Rather than merging master\u2019s new commits into feature, we opt to rebase our feature branch onto master. git checkout feature git rebase master At a high level, rebasing can be understood as \u201cmoving the base of a branch onto a different position\u201d. Think of it like a redo\u200a\u2014\u200a\u201cI meant to start here.\u201d At a lower level, what rebase actually does is pluck commits from a branch one by one (chronologically) and re-attach them to a different commit. The point at which the branch\u2026branched has now changed. You might see from the diagrams above why we would choose to rebase instead of merge in this situation. Unlike with merging, rebase does not create an extra commit. This is ideal for our situation, since all we are currently trying to do is keep our feature branch up-to-date with any new commits from master. This is definitely not a meaningful event we want to preserve in our project\u2019s history. Although the changes on the newly rebased feature branch are identical to what they were before, it is good to note that, from Git\u2019s perspective, these are new commits with new SHA\u2019s (the commits\u2019 identifiers). But even more importantly, realize that the feature branch\u2019s history has been completely rewritten. That sounds a bit heavy, doesn\u2019t it? You might wonder if there are implications to this you should worry about. The Golden Rule of Rebasing Once you understand what rebasing is, the most important thing to learn is when not to do it. The golden rule of git rebase is to never use it on public branches. For example, think about what would happen if you rebased master onto your feature branch: The rebase moves all of the commits in master onto the tip of feature. The problem is that this only happened in your repository. All of the other developers are still working with the original master. Since rebasing results in brand new commits, Git will think that your master branch\u2019s history has diverged from everybody else\u2019s. The only way to synchronize the two master branches is to merge them back together, resulting in an extra merge commit and two sets of commits that contain the same changes (the original ones, and the ones from your rebased branch). Needless to say, this is a very confusing situation. So, before you run git rebase, always ask yourself, \u201cIs anyone else looking at this branch?\u201d If the answer is yes, take your hands off the keyboard and start thinking about a non-destructive way to make your changes (e.g., the git revert command). Otherwise, you\u2019re safe to re-write history as much as you like. Atlassian's Merging vs. Rebasing Rebase Your Feature Branch The rebase command has some awesome options available in its --interactive (or -i ) mode, and one of the most widely used is the ability to squash commits. What this does is take smaller commits and combine them into larger ones, which could be useful if you\u2019re wrapping up the day\u2019s work or if you just want to package your changes differently. We\u2019re going to go over how you can do this easily. Caution Only do this on commits that haven\u2019t been pushed an external repository. If others have based work off of the commits that you\u2019re going to delete, plenty of conflicts can occur. Just don\u2019t rewrite your history if it\u2019s been shared with others. So let\u2019s say you\u2019ve just made a few small commits, and you want to make one larger commit out of them. Our repository\u2019s history currently looks like this: The last 4 commits would be much happier if they were wrapped up together, so let\u2019s do just that through interactive rebasing: $ git rebase -i HEAD~4 pick 01d1124 Adding license pick 6340aaa Moving license into its own file pick ebfd367 Jekyll has become self-aware. pick 30e0ccb Changed the tagline in the binary, too. # Rebase 60709da..30e0ccb onto 60709da # # Commands: # p, pick = use commit # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # # If you remove a line here THAT COMMIT WILL BE LOST. # However, if you remove everything, the rebase will be aborted. # So, a few things have happened here. First of all, I told Git that I wanted to rebase using the last four commits from where the HEAD is with HEAD~4 . So if you had 19 commits, it would be HEAD~19 . Git has now put me into an editor with the above text in it, and a little explanation of what can be done. You have plenty of options available to you from this screen, but right now we\u2019re just going to squash everything into one commit. So, changing the first four lines of the file to this will do the trick: pick 01d1124 Adding license squash 6340aaa Moving license into its own file squash ebfd367 Jekyll has become self-aware. squash 30e0ccb Changed the tagline in the binary, too. Basically this tells Git to combine all four commits into the the first commit in the list. Once this is done and saved, another editor pops up with the following: # This is a combination of 4 commits. # The first commit's message is: Adding license # This is the 2nd commit message: Moving license into its own file # This is the 3rd commit message: Jekyll has become self-aware. # This is the 4th commit message: Changed the tagline in the binary, too. # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # Explicit paths specified without -i nor -o; assuming --only paths... # Not currently on any branch. # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # new file: LICENSE # modified: README.textile # modified: Rakefile # modified: bin/jekyll # Since we\u2019re combining so many commits, Git allows you to modify the new commit\u2019s message based on the rest of the commits involved in the process. Edit the message as you see fit, then save and quit. Once that\u2019s done, your commits have been successfully squashed! Created commit 0fc4eea: Creating license file, and making jekyll self-aware. 4 files changed, 27 insertions ( + ) , 30 deletions ( - ) create mode 100644 LICENSE Successfully rebased and updated refs/heads/master. And if we look at the history again... So, this has been a relatively painless so far. If you run into conflicts during the rebase, they\u2019re usually quite easy to resolve and Git leads you through as much as possible. The basics of this is fix the conflict in question, git add the file, and then git rebase --continue will resume the process. Of course, doing a git rebase --abort will bring you back to your previous state if you want. If for some reason you\u2019ve lost a commit in the rebase, you can use the reflog to get it back. Info Based on the article written by Nick Quaranto Squashing Commits with Rebase","title":"Commits"},{"location":"contribute/commit/#introduction","text":"A project\u2019s long-term success rests (among other things) on its maintainability, and a maintainer has few tools more powerful than his project\u2019s log. It\u2019s worth taking the time to learn how to care for one properly. What may be a hassle at first soon becomes habit, and eventually a source of pride and productivity for all involved. Most programming languages have well-established conventions as to what constitutes idiomatic style, i.e. naming, formatting and so on. There are variations on these conventions, of course, but most developers agree that picking one and sticking to it is far better than the chaos that ensues when everybody does their own thing. Reviewing others\u2019 commits and pull requests becomes something worth doing, and suddenly can be done independently. Understanding why something happened months or years ago becomes not only possible but efficient. Fortunately, there are well-established conventions as to what makes an idiomatic Git commit message. Indeed, many of them are assumed in the way certain Git commands function. There\u2019s nothing you need to re-invent. Just follow the seven rules below and you\u2019re on your way to committing like a pro. Requirement Don't forget to sign your commits with the -s flag.","title":"Introduction"},{"location":"contribute/commit/#the-seven-rules-for-great-git-commit-messages","text":"Separate subject from body with a blank line Limit the subject line to 50 characters Capitalize the subject line Do not end the subject line with a period Use the imperative mood in the subject line Wrap the body at 72 characters Use the body to explain what and why and not the how Example: Summarize changes in around 50 characters or less More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. In some contexts, the first line is treated as the subject of the commit and the rest of the text as the body. The blank line separating the summary from the body is critical ( unless you omit the body entirely ) ; various tools like 'log' , 'shortlog' and 'rebase' can get confused if you run the two together. Explain the problem that this commit is solving. Focus on why you are making this change as opposed to how ( the code explains that ) . Are there side effects or other un-intuitive consequences of this change? Here is the place to explain them. Further paragraphs come after blank lines. - Bullet points are okay, too - Typically a hyphen or asterisk is used for the bullet, preceded by a single space, with blank lines in between, but conventions vary here If you use an issue tracker, put references to them at the bottom, like this: Resolves: #123 See also: #456, #789 Info To read more about the 7 rules, visit Chris Beams How to Write a Git Commit Message article.","title":"The Seven Rules for Great Git Commit Messages"},{"location":"contribute/commit/#git-commit-message-template","text":"A commit message template helps you write great commit messages and enforce it across teams. You can save the template somewhere it can be accessed by all projects and saved to your git global configuration. git config --global commit.template ~/.git-commit-template.txt If you want empty commit messages (should be avoided but there might be a reason): git config --global commit.cleanup strip This prevents git from using the template as the commit message.","title":"Git Commit Message Template"},{"location":"contribute/commit/#git-commit-templatetxt","text":"# <type>: (If applied, this commit will...) <subject> (Max 50 char) # |<---- Using a Maximum Of 50 Characters ---->| # Explain why this change is being made # |<---- Try To Limit Each Line to a Maximum Of 72 Characters ---->| # Provide links or keys to any relevant tickets, articles or other resources # Example: Github issue #23 # --- COMMIT END --- # Type: # feat (new feature) # fix (bug fix) # refactor (refactoring production code) # style (formatting, missing semi colons, etc; no code change) # docs (changes to documentation) # test (adding or refactoring tests; no production code change) # chore (updating grunt tasks etc; no production code change) # -------------------- # Remember to # 1. Separate subject from body with a blank line # 2. Limit the subject line to 50 characters # 3. Capitalize the subject line # 4. Do not end the subject line with a period # 5. Use the imperative mood in the subject line # 6. Wrap the body at 72 characters # 7. Use the body to explain what and why and not the how # -------------------- # For more information about this template, check out # https://gist.github.com/adeekshith/cd4c95a064977cdc6c50","title":"git-commit-template.txt"},{"location":"contribute/commit/#squashing-commits","text":"Squash your feature's commits before requesting a pull request into the develop branch.","title":"Squashing Commits"},{"location":"contribute/commit/#merging-vs-rebase","text":"In our project\u2019s Git repository, two branches currently exist: the usual master branch, and a feature branch that we created right after the initial commit. On the master branch, we have italicized the \u2018a\u2019, then bolded the \u2018a\u2019. On our feature branch, we have italicized the \u2018b\u2019, and then bolded the \u2018b\u2019.","title":"Merging vs Rebase"},{"location":"contribute/commit/#merge","text":"By merging feature into master, master obtains a new commit\u200a\u2014\u200aa \u201cmerge commit\u201d. All by itself, the merge commit represents every change that has occurred on feature since it branched from master. Clean and simple. The downside of merging? If used too liberally, merge commits can clutter up your Git logs, and make it much more difficult to understand the flow of your project\u2019s history. For collaborative workflows in which other developers (and potentially even project managers/leads or QA) read your project\u2019s Git logs for insight and context, readability is important. To avoid this pitfall, try to use merges purposefully and sparingly. Avoid branching and merging when only making minor tweaks or trivial bug fixes. Use merge for cases where you want a set of commits to stand out. Large refactors and major feature additions are good candidates for separate feature branches that can later be merged into master. As an added bonus, when merges are reserved for these major changes, the merge commits act as milestones that others can use to figure out when these major changes were incorporated into the project.","title":"Merge"},{"location":"contribute/commit/#rebase","text":"Let\u2019s rewind, and pretend that we instead wanted to keep working on styling the letter \u2018b\u2019\u200a\u2014\u200amaybe change its size, font, color, etc. We need to get it just right\u200a\u2014\u200athis change affects 50% of our codebase! But before we continue working on our feature branch, we decide we want to bring in the latest changes from master to keep things fresh. Rather than merging master\u2019s new commits into feature, we opt to rebase our feature branch onto master. git checkout feature git rebase master At a high level, rebasing can be understood as \u201cmoving the base of a branch onto a different position\u201d. Think of it like a redo\u200a\u2014\u200a\u201cI meant to start here.\u201d At a lower level, what rebase actually does is pluck commits from a branch one by one (chronologically) and re-attach them to a different commit. The point at which the branch\u2026branched has now changed. You might see from the diagrams above why we would choose to rebase instead of merge in this situation. Unlike with merging, rebase does not create an extra commit. This is ideal for our situation, since all we are currently trying to do is keep our feature branch up-to-date with any new commits from master. This is definitely not a meaningful event we want to preserve in our project\u2019s history. Although the changes on the newly rebased feature branch are identical to what they were before, it is good to note that, from Git\u2019s perspective, these are new commits with new SHA\u2019s (the commits\u2019 identifiers). But even more importantly, realize that the feature branch\u2019s history has been completely rewritten. That sounds a bit heavy, doesn\u2019t it? You might wonder if there are implications to this you should worry about.","title":"Rebase"},{"location":"contribute/commit/#the-golden-rule-of-rebasing","text":"Once you understand what rebasing is, the most important thing to learn is when not to do it. The golden rule of git rebase is to never use it on public branches. For example, think about what would happen if you rebased master onto your feature branch: The rebase moves all of the commits in master onto the tip of feature. The problem is that this only happened in your repository. All of the other developers are still working with the original master. Since rebasing results in brand new commits, Git will think that your master branch\u2019s history has diverged from everybody else\u2019s. The only way to synchronize the two master branches is to merge them back together, resulting in an extra merge commit and two sets of commits that contain the same changes (the original ones, and the ones from your rebased branch). Needless to say, this is a very confusing situation. So, before you run git rebase, always ask yourself, \u201cIs anyone else looking at this branch?\u201d If the answer is yes, take your hands off the keyboard and start thinking about a non-destructive way to make your changes (e.g., the git revert command). Otherwise, you\u2019re safe to re-write history as much as you like. Atlassian's Merging vs. Rebasing","title":"The Golden Rule of Rebasing"},{"location":"contribute/commit/#rebase-your-feature-branch","text":"The rebase command has some awesome options available in its --interactive (or -i ) mode, and one of the most widely used is the ability to squash commits. What this does is take smaller commits and combine them into larger ones, which could be useful if you\u2019re wrapping up the day\u2019s work or if you just want to package your changes differently. We\u2019re going to go over how you can do this easily. Caution Only do this on commits that haven\u2019t been pushed an external repository. If others have based work off of the commits that you\u2019re going to delete, plenty of conflicts can occur. Just don\u2019t rewrite your history if it\u2019s been shared with others. So let\u2019s say you\u2019ve just made a few small commits, and you want to make one larger commit out of them. Our repository\u2019s history currently looks like this: The last 4 commits would be much happier if they were wrapped up together, so let\u2019s do just that through interactive rebasing: $ git rebase -i HEAD~4 pick 01d1124 Adding license pick 6340aaa Moving license into its own file pick ebfd367 Jekyll has become self-aware. pick 30e0ccb Changed the tagline in the binary, too. # Rebase 60709da..30e0ccb onto 60709da # # Commands: # p, pick = use commit # e, edit = use commit, but stop for amending # s, squash = use commit, but meld into previous commit # # If you remove a line here THAT COMMIT WILL BE LOST. # However, if you remove everything, the rebase will be aborted. # So, a few things have happened here. First of all, I told Git that I wanted to rebase using the last four commits from where the HEAD is with HEAD~4 . So if you had 19 commits, it would be HEAD~19 . Git has now put me into an editor with the above text in it, and a little explanation of what can be done. You have plenty of options available to you from this screen, but right now we\u2019re just going to squash everything into one commit. So, changing the first four lines of the file to this will do the trick: pick 01d1124 Adding license squash 6340aaa Moving license into its own file squash ebfd367 Jekyll has become self-aware. squash 30e0ccb Changed the tagline in the binary, too. Basically this tells Git to combine all four commits into the the first commit in the list. Once this is done and saved, another editor pops up with the following: # This is a combination of 4 commits. # The first commit's message is: Adding license # This is the 2nd commit message: Moving license into its own file # This is the 3rd commit message: Jekyll has become self-aware. # This is the 4th commit message: Changed the tagline in the binary, too. # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # Explicit paths specified without -i nor -o; assuming --only paths... # Not currently on any branch. # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # new file: LICENSE # modified: README.textile # modified: Rakefile # modified: bin/jekyll # Since we\u2019re combining so many commits, Git allows you to modify the new commit\u2019s message based on the rest of the commits involved in the process. Edit the message as you see fit, then save and quit. Once that\u2019s done, your commits have been successfully squashed! Created commit 0fc4eea: Creating license file, and making jekyll self-aware. 4 files changed, 27 insertions ( + ) , 30 deletions ( - ) create mode 100644 LICENSE Successfully rebased and updated refs/heads/master. And if we look at the history again... So, this has been a relatively painless so far. If you run into conflicts during the rebase, they\u2019re usually quite easy to resolve and Git leads you through as much as possible. The basics of this is fix the conflict in question, git add the file, and then git rebase --continue will resume the process. Of course, doing a git rebase --abort will bring you back to your previous state if you want. If for some reason you\u2019ve lost a commit in the rebase, you can use the reflog to get it back. Info Based on the article written by Nick Quaranto Squashing Commits with Rebase","title":"Rebase Your Feature Branch"},{"location":"contribute/fork/","text":"Forking A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project. A great example of using forks to propose changes is for bug fixes. Rather than logging an issue for a bug you've found. You can: Fork the repo Make the fix Submit a pull request for the project If I like you're work and it meets the Code Style Guidelines, I might pull your fix into the original repository! Fork the Repo Navigate to the project's repository on GitHub In the top-right corner of the page, click Fork Keeping your fork synced You might fork a project in order to propose changes to the upstream , or original, repository. In this case, it's good practice to regularly sync your fork with the upstream repository. Info The following is based on an article by Chris Simpkins . The Problem A downstream repo (aka the \"fork\") you just made commonly needs to stay current with the upstream work (aka the original repo). The following steps allow you to achieve this. Add the Remote Upstream Repo This step defines the upstream repo of your fork. Replace the <URL.git> with the original repo's URL without the < >. git remote add upstream <URL.git> Getting the latest Upstream Changes You will want to run this command the first time you add the upstream repo. This will ensure you are connected to the repo correctly. git remote -v This will show you something like the following: > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git ( fetch ) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git ( push ) > upstream https://github.com/rowland007/ORIGINAL_REPOSITORY.git ( fetch ) > upstream https://github.com/rowland007/ORIGINAL_REPOSITORY.git ( push ) After you verify you're connected you can get the branches you'll be working with. You will also use this command to stay up-to-date with the upstream repo. I suggest running this command each time you open the project before you start making changes. This will ensure you're on the latest changes. git fetch upstream Merging Upstream changes into your Downstream Repo From your develop branch, use the following merge command to merge the upstream develop branch changes into your local source: git merge -S upstream/develop Very rarely will my projects not have a develop branch (usually my websites like this one). When there is a develop branch, no work should take place from the master branch. Tip Big take away here is: upstream & original means they are mine downstream , fork , and origin are yours See the next section about creating a new branch for your work.","title":"Forking"},{"location":"contribute/fork/#forking","text":"A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project. A great example of using forks to propose changes is for bug fixes. Rather than logging an issue for a bug you've found. You can: Fork the repo Make the fix Submit a pull request for the project If I like you're work and it meets the Code Style Guidelines, I might pull your fix into the original repository!","title":"Forking"},{"location":"contribute/fork/#fork-the-repo","text":"Navigate to the project's repository on GitHub In the top-right corner of the page, click Fork","title":"Fork the Repo"},{"location":"contribute/fork/#keeping-your-fork-synced","text":"You might fork a project in order to propose changes to the upstream , or original, repository. In this case, it's good practice to regularly sync your fork with the upstream repository. Info The following is based on an article by Chris Simpkins .","title":"Keeping your fork synced"},{"location":"contribute/fork/#the-problem","text":"A downstream repo (aka the \"fork\") you just made commonly needs to stay current with the upstream work (aka the original repo). The following steps allow you to achieve this.","title":"The Problem"},{"location":"contribute/fork/#add-the-remote-upstream-repo","text":"This step defines the upstream repo of your fork. Replace the <URL.git> with the original repo's URL without the < >. git remote add upstream <URL.git>","title":"Add the Remote Upstream Repo"},{"location":"contribute/fork/#getting-the-latest-upstream-changes","text":"You will want to run this command the first time you add the upstream repo. This will ensure you are connected to the repo correctly. git remote -v This will show you something like the following: > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git ( fetch ) > origin https://github.com/YOUR_USERNAME/YOUR_FORK.git ( push ) > upstream https://github.com/rowland007/ORIGINAL_REPOSITORY.git ( fetch ) > upstream https://github.com/rowland007/ORIGINAL_REPOSITORY.git ( push ) After you verify you're connected you can get the branches you'll be working with. You will also use this command to stay up-to-date with the upstream repo. I suggest running this command each time you open the project before you start making changes. This will ensure you're on the latest changes. git fetch upstream","title":"Getting the latest Upstream Changes"},{"location":"contribute/fork/#merging-upstream-changes-into-your-downstream-repo","text":"From your develop branch, use the following merge command to merge the upstream develop branch changes into your local source: git merge -S upstream/develop Very rarely will my projects not have a develop branch (usually my websites like this one). When there is a develop branch, no work should take place from the master branch. Tip Big take away here is: upstream & original means they are mine downstream , fork , and origin are yours See the next section about creating a new branch for your work.","title":"Merging Upstream changes into your Downstream Repo"},{"location":"contribute/pull/","text":"Submitting Changes Pull requests let you tell others about changes you've pushed to a branch in a repository. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch. Tip If you have a lot of commits, squash them into a single commit. Tip Recommend that you use a topic branch for your pull request. While you can send pull requests from any branch or commit, with a topic branch you can push follow-up commits if you need to update your proposed changes. Danger When pushing commits to a pull request, don't force push. Force pushing can corrupt your pull request. Creating the Pull Request On GitHub, navigate to the main page of the repository. In the \"Branch\" menu, choose the branch that contains your commits. Note More than likely, you will choose your feature/ branch. Look for the New pull request button. Use the base branch dropdown menu to select the branch you'd like to merge your changes into, then use the compare branch drop-down menu to choose the topic branch you made your changes in. Note More than likely, you will choose the develop branch. You are asking to add your feature/ branch into develop . Type a title and description for your pull request. For more details on writing a good pull requests, see Writing the Pull Request section below. Tip Describe the pull request's impact on the project in the title. Like the commits type, you can use keywords at the beginning of the title to signify what the what you want the pull request to do: Added - for new features. Changed - for changes in existing functionality. Deprecated - for once-stable features removed in upcoming releases. Removed - for deprecated features removed in this release. Fixed - for any bug fixes. Security - to invite users to upgrade in case of vulnerabilities. [WIP] - DO NOT USE in master branch To create a pull request that is ready for review, click Create Pull Request. To create a draft pull request, use the drop-down and select Create Draft Pull Request, then click Draft Pull Request. Info For more information about draft pull requests, see GitHub's About pull requests Writing the Pull Request After you open a pull request in a repository, collaborators or team members can comment on the comparison of files between the two specified branches, or leave general comments on the project as a whole. The title should state the overall impact to the project such as, Added a button to the <blah> interface , Removed unused code , Security: patched CVE-2019XXX , or Fixed gh issue #243 . Include the purpose of this Pull Request in the description. For example: This is a spike to explore\u2026 , This simplifies the display of\u2026 , This fixes handling of\u2026 Within the description, consider providing an overview of why the work is taking place (with any relevant links); don\u2019t assume familiarity with the history. Tip Remember that anyone could be reading this Pull Request, so the content and tone may inform people other than those taking part, now or later. Explain the what and why and not the how. Be explicit about what feedback you want, if any: a quick pair of eyes on the code, discussion on the technical approach, critique on design, a review of copy. Be explicit about when you want feedback, if the Pull Request is work in progress, say so. A prefix of \u201c [WIP] \u201d in the title is a simple, common pattern to indicate that state. WIP should be limited but maybe you got stuck and need some help or you want to ensure you are heading in the right direction with the feature. Avoid WIP should never be requested into the master branch Use @mention individuals that you specifically want to involve in the discussion, and mention why. (\u201c/cc @rowland007 for clarification on this logic\u201d) or @mention teams that you want to involve in the discussion, and mention why. (\u201c/cc @github/security, any concerns with this approach?\u201d) Offering feedback Familiarize yourself with the context of the issue, and reasons why this Pull Request exists. If you disagree strongly, consider giving it a few minutes before responding; think before you react. Ask, don\u2019t tell. (\u201cWhat do you think about trying\u2026?\u201d rather than \u201cDon\u2019t do\u2026\u201d) Explain your reasons why code should be changed. (Not in line with the style guide? A personal preference?) Offer ways to simplify or improve code. Avoid using derogatory terms, like \u201cstupid\u201d, when referring to the work someone has produced. Be humble. (\u201cI\u2019m not sure, let\u2019s try\u2026\u201d) Avoid hyperbole. (\u201cNEVER do\u2026\u201d) Aim to develop professional skills, group knowledge and product quality, through group critique. Be aware of negative bias with online communication. (If content is neutral, we assume the tone is negative.) Can you use positive language as opposed to neutral? You may use emoji to clarify tone. GitHub emoji list Emoji Examples Can some one get some on this please? Looks good, let's get this merged! SECURITY ALERT: App is vulnerable to CVE-2019XXX Responding to feedback Consider leading with an expression of appreciation, especially when feedback has been mixed. Ask for clarification. (\u201cI don\u2019t understand, can you clarify? \u201d) Offer clarification, explain the decisions you made to reach a solution in question. Try to respond to every comment. Link to any follow up commits or Pull Requests. (\u201cGood call! Done in issue #1682851\u201d) As a last resort, if there is growing confusion or debate, ask yourself if the written word is still the best form of communication. Talk (virtually) face-to-face, then mutually consider posting a follow-up to summarize any offline discussion (useful for others who be following along, now or later).","title":"Pull Request"},{"location":"contribute/pull/#submitting-changes","text":"Pull requests let you tell others about changes you've pushed to a branch in a repository. Once a pull request is opened, you can discuss and review the potential changes with collaborators and add follow-up commits before your changes are merged into the base branch. Tip If you have a lot of commits, squash them into a single commit. Tip Recommend that you use a topic branch for your pull request. While you can send pull requests from any branch or commit, with a topic branch you can push follow-up commits if you need to update your proposed changes. Danger When pushing commits to a pull request, don't force push. Force pushing can corrupt your pull request.","title":"Submitting Changes"},{"location":"contribute/pull/#creating-the-pull-request","text":"On GitHub, navigate to the main page of the repository. In the \"Branch\" menu, choose the branch that contains your commits. Note More than likely, you will choose your feature/ branch. Look for the New pull request button. Use the base branch dropdown menu to select the branch you'd like to merge your changes into, then use the compare branch drop-down menu to choose the topic branch you made your changes in. Note More than likely, you will choose the develop branch. You are asking to add your feature/ branch into develop . Type a title and description for your pull request. For more details on writing a good pull requests, see Writing the Pull Request section below. Tip Describe the pull request's impact on the project in the title. Like the commits type, you can use keywords at the beginning of the title to signify what the what you want the pull request to do: Added - for new features. Changed - for changes in existing functionality. Deprecated - for once-stable features removed in upcoming releases. Removed - for deprecated features removed in this release. Fixed - for any bug fixes. Security - to invite users to upgrade in case of vulnerabilities. [WIP] - DO NOT USE in master branch To create a pull request that is ready for review, click Create Pull Request. To create a draft pull request, use the drop-down and select Create Draft Pull Request, then click Draft Pull Request. Info For more information about draft pull requests, see GitHub's About pull requests","title":"Creating the Pull Request"},{"location":"contribute/pull/#writing-the-pull-request","text":"After you open a pull request in a repository, collaborators or team members can comment on the comparison of files between the two specified branches, or leave general comments on the project as a whole. The title should state the overall impact to the project such as, Added a button to the <blah> interface , Removed unused code , Security: patched CVE-2019XXX , or Fixed gh issue #243 . Include the purpose of this Pull Request in the description. For example: This is a spike to explore\u2026 , This simplifies the display of\u2026 , This fixes handling of\u2026 Within the description, consider providing an overview of why the work is taking place (with any relevant links); don\u2019t assume familiarity with the history. Tip Remember that anyone could be reading this Pull Request, so the content and tone may inform people other than those taking part, now or later. Explain the what and why and not the how. Be explicit about what feedback you want, if any: a quick pair of eyes on the code, discussion on the technical approach, critique on design, a review of copy. Be explicit about when you want feedback, if the Pull Request is work in progress, say so. A prefix of \u201c [WIP] \u201d in the title is a simple, common pattern to indicate that state. WIP should be limited but maybe you got stuck and need some help or you want to ensure you are heading in the right direction with the feature. Avoid WIP should never be requested into the master branch Use @mention individuals that you specifically want to involve in the discussion, and mention why. (\u201c/cc @rowland007 for clarification on this logic\u201d) or @mention teams that you want to involve in the discussion, and mention why. (\u201c/cc @github/security, any concerns with this approach?\u201d)","title":"Writing the Pull Request"},{"location":"contribute/pull/#offering-feedback","text":"Familiarize yourself with the context of the issue, and reasons why this Pull Request exists. If you disagree strongly, consider giving it a few minutes before responding; think before you react. Ask, don\u2019t tell. (\u201cWhat do you think about trying\u2026?\u201d rather than \u201cDon\u2019t do\u2026\u201d) Explain your reasons why code should be changed. (Not in line with the style guide? A personal preference?) Offer ways to simplify or improve code. Avoid using derogatory terms, like \u201cstupid\u201d, when referring to the work someone has produced. Be humble. (\u201cI\u2019m not sure, let\u2019s try\u2026\u201d) Avoid hyperbole. (\u201cNEVER do\u2026\u201d) Aim to develop professional skills, group knowledge and product quality, through group critique. Be aware of negative bias with online communication. (If content is neutral, we assume the tone is negative.) Can you use positive language as opposed to neutral? You may use emoji to clarify tone. GitHub emoji list Emoji Examples Can some one get some on this please? Looks good, let's get this merged! SECURITY ALERT: App is vulnerable to CVE-2019XXX","title":"Offering feedback"},{"location":"contribute/pull/#responding-to-feedback","text":"Consider leading with an expression of appreciation, especially when feedback has been mixed. Ask for clarification. (\u201cI don\u2019t understand, can you clarify? \u201d) Offer clarification, explain the decisions you made to reach a solution in question. Try to respond to every comment. Link to any follow up commits or Pull Requests. (\u201cGood call! Done in issue #1682851\u201d) As a last resort, if there is growing confusion or debate, ask yourself if the written word is still the best form of communication. Talk (virtually) face-to-face, then mutually consider posting a follow-up to summarize any offline discussion (useful for others who be following along, now or later).","title":"Responding to feedback"},{"location":"static/page/construction/","text":"UNDER CONSTRUCTION","title":"UNDER CONSTRUCTION"},{"location":"static/page/construction/#under-construction","text":"","title":"UNDER CONSTRUCTION"},{"location":"style-guide/","text":"Introduction This first page is a guide to producing readable, reusable, and refactorable software that should be language independent. Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages and this is a good working base to start from. Readability Readability is the simplest way of assessing code quality and it's the most straightforward to fix. It is the most obvious thing you see right when you open up a piece of code, and it generally consists of: Formatting Variable names Function names Amount of function arguments Function length (number of lines) Nesting levels These aren't the only things to consider, but they are immediate red flags. Reusability Reusability is the sole reason you are able to read this code, communicate with strangers online, and even program at all. Reusability allows us to express new ideas with little pieces of the past. That is why reusability is such an essential concept that should guide your software architecture. We commonly think of reusability in terms of DRY (Don't Repeat Yourself). That is one aspect of it -- don't have duplicate code if you can abstract it properly. Reusability goes beyond that though. It's about making clean, simple APIs that make your fellow programmer say, \"Yep, I know exactly what that does!\" Reusability makes your code a delight to work with, and it means you can ship features faster. Refactorability Code that is refactorable is code that you can change without fear. It's code that you can deploy on a Friday night, and come back to on Monday morning without any concern that your users encountered runtime errors. Refactorability is about the system as a whole. It's about how your reusable modules connect together like LEGO pieces. If you change your Employee module and somehow it breaks your Reporting module, then you know you have some refactorability issues. Refactorability is the highest piece of the 3 R hierarchy, and it's the hardest to achieve and maintain. There will always be issues with any human system, and code is no different. However, there are things that we can do to make our code refactorable: Isolated side effects Tests Static types SOLID Single Responsibility Principle (SRP) As stated in Clean Code, \"There should never be more than one reason for a class to change\". It's tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight. The issue with this is that your class won't be conceptually cohesive and it will give it many reasons to change. Minimizing the amount of times you need to change a class is important. It's important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase. Bad class UserSettings { constructor ( user ) { this . user = user ; } changeSettings ( settings ) { if ( this . verifyCredentials ()) { // ... } } verifyCredentials () { // ... } } Good class UserAuth { constructor ( user ) { this . user = user ; } verifyCredentials () { // ... } } class UserSettings { constructor ( user ) { this . user = user ; this . auth = new UserAuth ( user ); } changeSettings ( settings ) { if ( this . auth . verifyCredentials ()) { // ... } } } Open/Closed Principle (OCP) As stated by Bertrand Meyer, \"software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.\" What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code. Bad class AjaxAdapter extends Adapter { constructor () { super (); this . name = \"ajaxAdapter\" ; } } class NodeAdapter extends Adapter { constructor () { super (); this . name = \"nodeAdapter\" ; } } class HttpRequester { constructor ( adapter ) { this . adapter = adapter ; } fetch ( url ) { if ( this . adapter . name === \"ajaxAdapter\" ) { return makeAjaxCall ( url ). then ( response => { // transform response and return }); } else if ( this . adapter . name === \"nodeAdapter\" ) { return makeHttpCall ( url ). then ( response => { // transform response and return }); } } } function makeAjaxCall ( url ) { // request and return promise } function makeHttpCall ( url ) { // request and return promise } Good class AjaxAdapter extends Adapter { constructor () { super (); this . name = \"ajaxAdapter\" ; } request ( url ) { // request and return promise } } class NodeAdapter extends Adapter { constructor () { super (); this . name = \"nodeAdapter\" ; } request ( url ) { // request and return promise } } class HttpRequester { constructor ( adapter ) { this . adapter = adapter ; } fetch ( url ) { return this . adapter . request ( url ). then ( response => { // transform response and return }); } } Liskov Substitution Principle (LSP) This is a scary term for a very simple concept. It's formally defined as \"If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).\" That's an even scarier definition. The best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting incorrect results. This might still be confusing, so let's take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but if you model it using the \"is-a\" relationship via inheritance, you quickly get into trouble. Bad class Rectangle { constructor () { this . width = 0 ; this . height = 0 ; } setColor ( color ) { // ... } render ( area ) { // ... } setWidth ( width ) { this . width = width ; } setHeight ( height ) { this . height = height ; } getArea () { return this . width * this . height ; } } class Square extends Rectangle { setWidth ( width ) { this . width = width ; this . height = width ; } setHeight ( height ) { this . width = height ; this . height = height ; } } function renderLargeRectangles ( rectangles ) { rectangles . forEach ( rectangle => { rectangle . setWidth ( 4 ); rectangle . setHeight ( 5 ); const area = rectangle . getArea (); // BAD: Returns 25 for Square. Should be 20. rectangle . render ( area ); }); } const rectangles = [ new Rectangle (), new Rectangle (), new Square ()]; renderLargeRectangles ( rectangles ); Good class Shape { setColor ( color ) { // ... } render ( area ) { // ... } } class Rectangle extends Shape { constructor ( width , height ) { super (); this . width = width ; this . height = height ; } getArea () { return this . width * this . height ; } } class Square extends Shape { constructor ( length ) { super (); this . length = length ; } getArea () { return this . length * this . length ; } } function renderLargeShapes ( shapes ) { shapes . forEach ( shape => { const area = shape . getArea (); shape . render ( area ); }); } const shapes = [ new Rectangle ( 4 , 5 ), new Rectangle ( 4 , 5 ), new Square ( 5 )]; renderLargeShapes ( shapes ); Interface Segregation Principle (ISP) JavaScript doesn't have interfaces so this principle doesn't apply as strictly as others. However, it's important and relevant even with JavaScript's lack of type system. ISP states that \"Clients should not be forced to depend upon interfaces that they do not use.\" Interfaces are implicit contracts in JavaScript because of duck typing. A good example to look at that demonstrates this principle in JavaScript is for classes that require large settings objects. Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won't need all of the settings. Making them optional helps prevent having a \"fat interface\". Bad class DOMTraverser { constructor ( settings ) { this . settings = settings ; this . setup (); } setup () { this . rootNode = this . settings . rootNode ; this . animationModule . setup (); } traverse () { // ... } } const $ = new DOMTraverser ({ rootNode : document . getElementsByTagName ( \"body\" ), animationModule () {} // Most of the time, we won't need to animate when traversing. // ... }); Good class DOMTraverser { constructor ( settings ) { this . settings = settings ; this . options = settings . options ; this . setup (); } setup () { this . rootNode = this . settings . rootNode ; this . setupOptions (); } setupOptions () { if ( this . options . animationModule ) { // ... } } traverse () { // ... } } const $ = new DOMTraverser ({ rootNode : document . getElementsByTagName ( \"body\" ), options : { animationModule () {} } }); Dependency Inversion Principle (DIP) This principle states two essential things: High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions. This can be hard to understand at first, but if you've worked with AngularJS, you've seen an implementation of this principle in the form of Dependency Injection (DI). While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up. It can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules. Coupling is a very bad development pattern because it makes your code hard to refactor. As stated previously, JavaScript doesn't have interfaces so the abstractions that are depended upon are implicit contracts. That is to say, the methods and properties that an object/class exposes to another object/class. In the example below, the implicit contract is that any Request module for an InventoryTracker will have a requestItems method. Bad class InventoryRequester { constructor () { this . REQ_METHODS = [ \"HTTP\" ]; } requestItem ( item ) { // ... } } class InventoryTracker { constructor ( items ) { this . items = items ; // BAD: We have created a dependency on a specific request implementation. // We should just have requestItems depend on a request method: `request` this . requester = new InventoryRequester (); } requestItems () { this . items . forEach ( item => { this . requester . requestItem ( item ); }); } } const inventoryTracker = new InventoryTracker ([ \"apples\" , \"bananas\" ]); inventoryTracker . requestItems (); Good class InventoryTracker { constructor ( items , requester ) { this . items = items ; this . requester = requester ; } requestItems () { this . items . forEach ( item => { this . requester . requestItem ( item ); }); } } class InventoryRequesterV1 { constructor () { this . REQ_METHODS = [ \"HTTP\" ]; } requestItem ( item ) { // ... } } class InventoryRequesterV2 { constructor () { this . REQ_METHODS = [ \"WS\" ]; } requestItem ( item ) { // ... } } // By constructing our dependencies externally and injecting them, we can easily // substitute our request module for a fancy new one that uses WebSockets. const inventoryTracker = new InventoryTracker ( [ \"apples\" , \"bananas\" ], new InventoryRequesterV2 () ); inventoryTracker . requestItems (); Testing Testing is more important than shipping. If you have no tests or an inadequate amount, then every time you ship code you won't be sure that you didn't break anything. Deciding on what constitutes an adequate amount is up to your team, but having 100% coverage (all statements and branches) is how you achieve very high confidence and developer peace of mind. This means that in addition to having a great testing framework, you also need to use a good coverage tool . There's no excuse to not write tests. There are plenty of good JS test frameworks , so find one that your team prefers. When you find one that works for your team, then aim to always write tests for every new feature/module you introduce. If your preferred method is Test Driven Development (TDD), that is great, but the main point is to just make sure you are reaching your coverage goals before launching any feature, or refactoring an existing one. Single concept per test Bad import assert from \"assert\" ; describe ( \"MomentJS\" , () => { it ( \"handles date boundaries\" , () => { let date ; date = new MomentJS ( \"1/1/2015\" ); date . addDays ( 30 ); assert . equal ( \"1/31/2015\" , date ); date = new MomentJS ( \"2/1/2016\" ); date . addDays ( 28 ); assert . equal ( \"02/29/2016\" , date ); date = new MomentJS ( \"2/1/2015\" ); date . addDays ( 28 ); assert . equal ( \"03/01/2015\" , date ); }); }); Good import assert from \"assert\" ; describe ( \"MomentJS\" , () => { it ( \"handles 30-day months\" , () => { const date = new MomentJS ( \"1/1/2015\" ); date . addDays ( 30 ); assert . equal ( \"1/31/2015\" , date ); }); it ( \"handles leap year\" , () => { const date = new MomentJS ( \"2/1/2016\" ); date . addDays ( 28 ); assert . equal ( \"02/29/2016\" , date ); }); it ( \"handles non-leap year\" , () => { const date = new MomentJS ( \"2/1/2015\" ); date . addDays ( 28 ); assert . equal ( \"03/01/2015\" , date ); }); }); Concurrency Use Promises, not callbacks Callbacks aren't clean, and they cause excessive amounts of nesting. With ES2015/ES6, Promises are a built-in global type. Use them! Bad import { get } from \"request\" ; import { writeFile } from \"fs\" ; get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" , ( requestErr , response , body ) => { if ( requestErr ) { console . error ( requestErr ); } else { writeFile ( \"article.html\" , body , writeErr => { if ( writeErr ) { console . error ( writeErr ); } else { console . log ( \"File written\" ); } }); } } ); Good import { get } from \"request-promise\" ; import { writeFile } from \"fs-extra\" ; get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" ) . then ( body => { return writeFile ( \"article.html\" , body ); }) . then (() => { console . log ( \"File written\" ); }) . catch ( err => { console . error ( err ); }); Async/Await are even cleaner than Promises Promises are a very clean alternative to callbacks, but ES2017/ES8 brings async and await which offer an even cleaner solution. All you need is a function that is prefixed in an async keyword, and then you can write your logic imperatively without a then chain of functions. Use this if you can take advantage of ES2017/ES8 features today! Bad import { get } from \"request-promise\" ; import { writeFile } from \"fs-extra\" ; get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" ) . then ( body => { return writeFile ( \"article.html\" , body ); }) . then (() => { console . log ( \"File written\" ); }) . catch ( err => { console . error ( err ); }); Good import { get } from \"request-promise\" ; import { writeFile } from \"fs-extra\" ; async function getCleanCodeArticle () { try { const body = await get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" ); await writeFile ( \"article.html\" , body ); console . log ( \"File written\" ); } catch ( err ) { console . error ( err ); } } getCleanCodeArticle () Error Handling Thrown errors are a good thing! They mean the runtime has successfully identified when something in your program has gone wrong and it's letting you know by stopping function execution on the current stack, killing the process (in Node), and notifying you in the console with a stack trace. Don't ignore caught errors Doing nothing with a caught error doesn't give you the ability to ever fix or react to said error. Logging the error to the console ( console.log ) isn't much better as often times it can get lost in a sea of things printed to the console. If you wrap any bit of code in a try/catch it means you think an error may occur there and therefore you should have a plan, or create a code path, for when it occurs. Bad try { functionThatMightThrow (); } catch ( error ) { console . log ( error ); } Good try { functionThatMightThrow (); } catch ( error ) { // One option (more noisy than console.log): console . error ( error ); // Another option: notifyUserOfError ( error ); // Another option: reportErrorToService ( error ); // OR do all three! } Don't ignore rejected promises For the same reason you shouldn't ignore caught errors from try/catch . Bad getdata () . then ( data => { functionThatMightThrow ( data ); }) . catch ( error => { console . log ( error ); }); Good getdata () . then ( data => { functionThatMightThrow ( data ); }) . catch ( error => { // One option (more noisy than console.log): console . error ( error ); // Another option: notifyUserOfError ( error ); // Another option: reportErrorToService ( error ); // OR do all three! }); Formatting Formatting is subjective. Like many rules herein, there is no hard and fast rule that you must follow. The main point is DO NOT ARGUE over formatting. There are tons of tools to automate this. Use one! It's a waste of time and money for engineers to argue over formatting. For things that don't fall under the purview of automatic formatting (indentation, tabs vs. spaces, double vs. single quotes, etc.) look here for some guidance. Use consistent capitalization JavaScript is untyped, so capitalization tells you a lot about your variables, functions, etc. These rules are subjective, so your team can choose whatever they want. The point is, no matter what you all choose, just be consistent. Bad const DAYS_IN_WEEK = 7 ; const daysInMonth = 30 ; const songs = [ \"Back In Black\" , \"Stairway to Heaven\" , \"Hey Jude\" ]; const Artists = [ \"ACDC\" , \"Led Zeppelin\" , \"The Beatles\" ]; function eraseDatabase () {} function restore_database () {} class animal {} class Alpaca {} Good const DAYS_IN_WEEK = 7 ; const DAYS_IN_MONTH = 30 ; const SONGS = [ \"Back In Black\" , \"Stairway to Heaven\" , \"Hey Jude\" ]; const ARTISTS = [ \"ACDC\" , \"Led Zeppelin\" , \"The Beatles\" ]; function eraseDatabase () {} function restoreDatabase () {} class Animal {} class Alpaca {} Function callers and callees should be close If a function calls another, keep those functions vertically close in the source file. Ideally, keep the caller right above the callee. We tend to read code from top-to-bottom, like a newspaper. Because of this, make your code read that way. Bad class PerformanceReview { constructor ( employee ) { this . employee = employee ; } lookupPeers () { return db . lookup ( this . employee , \"peers\" ); } lookupManager () { return db . lookup ( this . employee , \"manager\" ); } getPeerReviews () { const peers = this . lookupPeers (); // ... } perfReview () { this . getPeerReviews (); this . getManagerReview (); this . getSelfReview (); } getManagerReview () { const manager = this . lookupManager (); } getSelfReview () { // ... } } const review = new PerformanceReview ( employee ); review . perfReview (); Good class PerformanceReview { constructor ( employee ) { this . employee = employee ; } perfReview () { this . getPeerReviews (); this . getManagerReview (); this . getSelfReview (); } getPeerReviews () { const peers = this . lookupPeers (); // ... } lookupPeers () { return db . lookup ( this . employee , \"peers\" ); } getManagerReview () { const manager = this . lookupManager (); } lookupManager () { return db . lookup ( this . employee , \"manager\" ); } getSelfReview () { // ... } } const review = new PerformanceReview ( employee ); review . perfReview (); Comments Only comment things that have business logic complexity Comments are an apology, not a requirement. Good code mostly documents itself. Bad function hashIt ( data ) { // The hash let hash = 0 ; // Length of string const length = data . length ; // Loop through every character in data for ( let i = 0 ; i < length ; i ++ ) { // Get character code. const char = data . charCodeAt ( i ); // Make the hash hash = ( hash << 5 ) - hash + char ; // Convert to 32-bit integer hash &= hash ; } } Good function hashIt ( data ) { let hash = 0 ; const length = data . length ; for ( let i = 0 ; i < length ; i ++ ) { const char = data . charCodeAt ( i ); hash = ( hash << 5 ) - hash + char ; // Convert to 32-bit integer hash &= hash ; } } Don't leave commented out code in your codebase Version control exists for a reason. Leave old code in your history. Bad doStuff (); // doOtherStuff(); // doSomeMoreStuff(); // doSoMuchStuff(); Good doStuff (); Don't have journal comments Remember, use version control! There's no need for dead code, commented code, and especially journal comments. Use git log to get history! Bad /** * 2016-12-20: Removed monads, didn't understand them (RM) * 2016-10-01: Improved using special monads (JP) * 2016-02-03: Removed type-checking (LI) * 2015-03-14: Added combine with type-checking (JR) */ function combine ( a , b ) { return a + b ; } Good function combine ( a , b ) { return a + b ; } Avoid positional markers They usually just add noise. Let the functions and variable names along with the proper indentation and formatting give the visual structure to your code. Bad //////////////////////////////////////////////////////////////////////////////// // Scope Model Instantiation //////////////////////////////////////////////////////////////////////////////// $scope . model = { menu : \"foo\" , nav : \"bar\" }; //////////////////////////////////////////////////////////////////////////////// // Action setup //////////////////////////////////////////////////////////////////////////////// const actions = function () { // ... }; Good $scope . model = { menu : \"foo\" , nav : \"bar\" }; const actions = function () { // ... };","title":"Introduction"},{"location":"style-guide/#introduction","text":"This first page is a guide to producing readable, reusable, and refactorable software that should be language independent. Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages and this is a good working base to start from.","title":"Introduction"},{"location":"style-guide/#readability","text":"Readability is the simplest way of assessing code quality and it's the most straightforward to fix. It is the most obvious thing you see right when you open up a piece of code, and it generally consists of: Formatting Variable names Function names Amount of function arguments Function length (number of lines) Nesting levels These aren't the only things to consider, but they are immediate red flags.","title":"Readability"},{"location":"style-guide/#reusability","text":"Reusability is the sole reason you are able to read this code, communicate with strangers online, and even program at all. Reusability allows us to express new ideas with little pieces of the past. That is why reusability is such an essential concept that should guide your software architecture. We commonly think of reusability in terms of DRY (Don't Repeat Yourself). That is one aspect of it -- don't have duplicate code if you can abstract it properly. Reusability goes beyond that though. It's about making clean, simple APIs that make your fellow programmer say, \"Yep, I know exactly what that does!\" Reusability makes your code a delight to work with, and it means you can ship features faster.","title":"Reusability"},{"location":"style-guide/#refactorability","text":"Code that is refactorable is code that you can change without fear. It's code that you can deploy on a Friday night, and come back to on Monday morning without any concern that your users encountered runtime errors. Refactorability is about the system as a whole. It's about how your reusable modules connect together like LEGO pieces. If you change your Employee module and somehow it breaks your Reporting module, then you know you have some refactorability issues. Refactorability is the highest piece of the 3 R hierarchy, and it's the hardest to achieve and maintain. There will always be issues with any human system, and code is no different. However, there are things that we can do to make our code refactorable: Isolated side effects Tests Static types","title":"Refactorability"},{"location":"style-guide/#solid","text":"","title":"SOLID"},{"location":"style-guide/#single-responsibility-principle-srp","text":"As stated in Clean Code, \"There should never be more than one reason for a class to change\". It's tempting to jam-pack a class with a lot of functionality, like when you can only take one suitcase on your flight. The issue with this is that your class won't be conceptually cohesive and it will give it many reasons to change. Minimizing the amount of times you need to change a class is important. It's important because if too much functionality is in one class and you modify a piece of it, it can be difficult to understand how that will affect other dependent modules in your codebase. Bad class UserSettings { constructor ( user ) { this . user = user ; } changeSettings ( settings ) { if ( this . verifyCredentials ()) { // ... } } verifyCredentials () { // ... } } Good class UserAuth { constructor ( user ) { this . user = user ; } verifyCredentials () { // ... } } class UserSettings { constructor ( user ) { this . user = user ; this . auth = new UserAuth ( user ); } changeSettings ( settings ) { if ( this . auth . verifyCredentials ()) { // ... } } }","title":"Single Responsibility Principle (SRP)"},{"location":"style-guide/#openclosed-principle-ocp","text":"As stated by Bertrand Meyer, \"software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.\" What does that mean though? This principle basically states that you should allow users to add new functionalities without changing existing code. Bad class AjaxAdapter extends Adapter { constructor () { super (); this . name = \"ajaxAdapter\" ; } } class NodeAdapter extends Adapter { constructor () { super (); this . name = \"nodeAdapter\" ; } } class HttpRequester { constructor ( adapter ) { this . adapter = adapter ; } fetch ( url ) { if ( this . adapter . name === \"ajaxAdapter\" ) { return makeAjaxCall ( url ). then ( response => { // transform response and return }); } else if ( this . adapter . name === \"nodeAdapter\" ) { return makeHttpCall ( url ). then ( response => { // transform response and return }); } } } function makeAjaxCall ( url ) { // request and return promise } function makeHttpCall ( url ) { // request and return promise } Good class AjaxAdapter extends Adapter { constructor () { super (); this . name = \"ajaxAdapter\" ; } request ( url ) { // request and return promise } } class NodeAdapter extends Adapter { constructor () { super (); this . name = \"nodeAdapter\" ; } request ( url ) { // request and return promise } } class HttpRequester { constructor ( adapter ) { this . adapter = adapter ; } fetch ( url ) { return this . adapter . request ( url ). then ( response => { // transform response and return }); } }","title":"Open/Closed Principle (OCP)"},{"location":"style-guide/#liskov-substitution-principle-lsp","text":"This is a scary term for a very simple concept. It's formally defined as \"If S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., objects of type S may substitute objects of type T) without altering any of the desirable properties of that program (correctness, task performed, etc.).\" That's an even scarier definition. The best explanation for this is if you have a parent class and a child class, then the base class and child class can be used interchangeably without getting incorrect results. This might still be confusing, so let's take a look at the classic Square-Rectangle example. Mathematically, a square is a rectangle, but if you model it using the \"is-a\" relationship via inheritance, you quickly get into trouble. Bad class Rectangle { constructor () { this . width = 0 ; this . height = 0 ; } setColor ( color ) { // ... } render ( area ) { // ... } setWidth ( width ) { this . width = width ; } setHeight ( height ) { this . height = height ; } getArea () { return this . width * this . height ; } } class Square extends Rectangle { setWidth ( width ) { this . width = width ; this . height = width ; } setHeight ( height ) { this . width = height ; this . height = height ; } } function renderLargeRectangles ( rectangles ) { rectangles . forEach ( rectangle => { rectangle . setWidth ( 4 ); rectangle . setHeight ( 5 ); const area = rectangle . getArea (); // BAD: Returns 25 for Square. Should be 20. rectangle . render ( area ); }); } const rectangles = [ new Rectangle (), new Rectangle (), new Square ()]; renderLargeRectangles ( rectangles ); Good class Shape { setColor ( color ) { // ... } render ( area ) { // ... } } class Rectangle extends Shape { constructor ( width , height ) { super (); this . width = width ; this . height = height ; } getArea () { return this . width * this . height ; } } class Square extends Shape { constructor ( length ) { super (); this . length = length ; } getArea () { return this . length * this . length ; } } function renderLargeShapes ( shapes ) { shapes . forEach ( shape => { const area = shape . getArea (); shape . render ( area ); }); } const shapes = [ new Rectangle ( 4 , 5 ), new Rectangle ( 4 , 5 ), new Square ( 5 )]; renderLargeShapes ( shapes );","title":"Liskov Substitution Principle (LSP)"},{"location":"style-guide/#interface-segregation-principle-isp","text":"JavaScript doesn't have interfaces so this principle doesn't apply as strictly as others. However, it's important and relevant even with JavaScript's lack of type system. ISP states that \"Clients should not be forced to depend upon interfaces that they do not use.\" Interfaces are implicit contracts in JavaScript because of duck typing. A good example to look at that demonstrates this principle in JavaScript is for classes that require large settings objects. Not requiring clients to setup huge amounts of options is beneficial, because most of the time they won't need all of the settings. Making them optional helps prevent having a \"fat interface\". Bad class DOMTraverser { constructor ( settings ) { this . settings = settings ; this . setup (); } setup () { this . rootNode = this . settings . rootNode ; this . animationModule . setup (); } traverse () { // ... } } const $ = new DOMTraverser ({ rootNode : document . getElementsByTagName ( \"body\" ), animationModule () {} // Most of the time, we won't need to animate when traversing. // ... }); Good class DOMTraverser { constructor ( settings ) { this . settings = settings ; this . options = settings . options ; this . setup (); } setup () { this . rootNode = this . settings . rootNode ; this . setupOptions (); } setupOptions () { if ( this . options . animationModule ) { // ... } } traverse () { // ... } } const $ = new DOMTraverser ({ rootNode : document . getElementsByTagName ( \"body\" ), options : { animationModule () {} } });","title":"Interface Segregation Principle (ISP)"},{"location":"style-guide/#dependency-inversion-principle-dip","text":"This principle states two essential things: High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend on abstractions. This can be hard to understand at first, but if you've worked with AngularJS, you've seen an implementation of this principle in the form of Dependency Injection (DI). While they are not identical concepts, DIP keeps high-level modules from knowing the details of its low-level modules and setting them up. It can accomplish this through DI. A huge benefit of this is that it reduces the coupling between modules. Coupling is a very bad development pattern because it makes your code hard to refactor. As stated previously, JavaScript doesn't have interfaces so the abstractions that are depended upon are implicit contracts. That is to say, the methods and properties that an object/class exposes to another object/class. In the example below, the implicit contract is that any Request module for an InventoryTracker will have a requestItems method. Bad class InventoryRequester { constructor () { this . REQ_METHODS = [ \"HTTP\" ]; } requestItem ( item ) { // ... } } class InventoryTracker { constructor ( items ) { this . items = items ; // BAD: We have created a dependency on a specific request implementation. // We should just have requestItems depend on a request method: `request` this . requester = new InventoryRequester (); } requestItems () { this . items . forEach ( item => { this . requester . requestItem ( item ); }); } } const inventoryTracker = new InventoryTracker ([ \"apples\" , \"bananas\" ]); inventoryTracker . requestItems (); Good class InventoryTracker { constructor ( items , requester ) { this . items = items ; this . requester = requester ; } requestItems () { this . items . forEach ( item => { this . requester . requestItem ( item ); }); } } class InventoryRequesterV1 { constructor () { this . REQ_METHODS = [ \"HTTP\" ]; } requestItem ( item ) { // ... } } class InventoryRequesterV2 { constructor () { this . REQ_METHODS = [ \"WS\" ]; } requestItem ( item ) { // ... } } // By constructing our dependencies externally and injecting them, we can easily // substitute our request module for a fancy new one that uses WebSockets. const inventoryTracker = new InventoryTracker ( [ \"apples\" , \"bananas\" ], new InventoryRequesterV2 () ); inventoryTracker . requestItems ();","title":"Dependency Inversion Principle (DIP)"},{"location":"style-guide/#testing","text":"Testing is more important than shipping. If you have no tests or an inadequate amount, then every time you ship code you won't be sure that you didn't break anything. Deciding on what constitutes an adequate amount is up to your team, but having 100% coverage (all statements and branches) is how you achieve very high confidence and developer peace of mind. This means that in addition to having a great testing framework, you also need to use a good coverage tool . There's no excuse to not write tests. There are plenty of good JS test frameworks , so find one that your team prefers. When you find one that works for your team, then aim to always write tests for every new feature/module you introduce. If your preferred method is Test Driven Development (TDD), that is great, but the main point is to just make sure you are reaching your coverage goals before launching any feature, or refactoring an existing one.","title":"Testing"},{"location":"style-guide/#single-concept-per-test","text":"Bad import assert from \"assert\" ; describe ( \"MomentJS\" , () => { it ( \"handles date boundaries\" , () => { let date ; date = new MomentJS ( \"1/1/2015\" ); date . addDays ( 30 ); assert . equal ( \"1/31/2015\" , date ); date = new MomentJS ( \"2/1/2016\" ); date . addDays ( 28 ); assert . equal ( \"02/29/2016\" , date ); date = new MomentJS ( \"2/1/2015\" ); date . addDays ( 28 ); assert . equal ( \"03/01/2015\" , date ); }); }); Good import assert from \"assert\" ; describe ( \"MomentJS\" , () => { it ( \"handles 30-day months\" , () => { const date = new MomentJS ( \"1/1/2015\" ); date . addDays ( 30 ); assert . equal ( \"1/31/2015\" , date ); }); it ( \"handles leap year\" , () => { const date = new MomentJS ( \"2/1/2016\" ); date . addDays ( 28 ); assert . equal ( \"02/29/2016\" , date ); }); it ( \"handles non-leap year\" , () => { const date = new MomentJS ( \"2/1/2015\" ); date . addDays ( 28 ); assert . equal ( \"03/01/2015\" , date ); }); });","title":"Single concept per test"},{"location":"style-guide/#concurrency","text":"","title":"Concurrency"},{"location":"style-guide/#use-promises-not-callbacks","text":"Callbacks aren't clean, and they cause excessive amounts of nesting. With ES2015/ES6, Promises are a built-in global type. Use them! Bad import { get } from \"request\" ; import { writeFile } from \"fs\" ; get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" , ( requestErr , response , body ) => { if ( requestErr ) { console . error ( requestErr ); } else { writeFile ( \"article.html\" , body , writeErr => { if ( writeErr ) { console . error ( writeErr ); } else { console . log ( \"File written\" ); } }); } } ); Good import { get } from \"request-promise\" ; import { writeFile } from \"fs-extra\" ; get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" ) . then ( body => { return writeFile ( \"article.html\" , body ); }) . then (() => { console . log ( \"File written\" ); }) . catch ( err => { console . error ( err ); });","title":"Use Promises, not callbacks"},{"location":"style-guide/#asyncawait-are-even-cleaner-than-promises","text":"Promises are a very clean alternative to callbacks, but ES2017/ES8 brings async and await which offer an even cleaner solution. All you need is a function that is prefixed in an async keyword, and then you can write your logic imperatively without a then chain of functions. Use this if you can take advantage of ES2017/ES8 features today! Bad import { get } from \"request-promise\" ; import { writeFile } from \"fs-extra\" ; get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" ) . then ( body => { return writeFile ( \"article.html\" , body ); }) . then (() => { console . log ( \"File written\" ); }) . catch ( err => { console . error ( err ); }); Good import { get } from \"request-promise\" ; import { writeFile } from \"fs-extra\" ; async function getCleanCodeArticle () { try { const body = await get ( \"https://en.wikipedia.org/wiki/Robert_Cecil_Martin\" ); await writeFile ( \"article.html\" , body ); console . log ( \"File written\" ); } catch ( err ) { console . error ( err ); } } getCleanCodeArticle ()","title":"Async/Await are even cleaner than Promises"},{"location":"style-guide/#error-handling","text":"Thrown errors are a good thing! They mean the runtime has successfully identified when something in your program has gone wrong and it's letting you know by stopping function execution on the current stack, killing the process (in Node), and notifying you in the console with a stack trace.","title":"Error Handling"},{"location":"style-guide/#dont-ignore-caught-errors","text":"Doing nothing with a caught error doesn't give you the ability to ever fix or react to said error. Logging the error to the console ( console.log ) isn't much better as often times it can get lost in a sea of things printed to the console. If you wrap any bit of code in a try/catch it means you think an error may occur there and therefore you should have a plan, or create a code path, for when it occurs. Bad try { functionThatMightThrow (); } catch ( error ) { console . log ( error ); } Good try { functionThatMightThrow (); } catch ( error ) { // One option (more noisy than console.log): console . error ( error ); // Another option: notifyUserOfError ( error ); // Another option: reportErrorToService ( error ); // OR do all three! }","title":"Don't ignore caught errors"},{"location":"style-guide/#dont-ignore-rejected-promises","text":"For the same reason you shouldn't ignore caught errors from try/catch . Bad getdata () . then ( data => { functionThatMightThrow ( data ); }) . catch ( error => { console . log ( error ); }); Good getdata () . then ( data => { functionThatMightThrow ( data ); }) . catch ( error => { // One option (more noisy than console.log): console . error ( error ); // Another option: notifyUserOfError ( error ); // Another option: reportErrorToService ( error ); // OR do all three! });","title":"Don't ignore rejected promises"},{"location":"style-guide/#formatting","text":"Formatting is subjective. Like many rules herein, there is no hard and fast rule that you must follow. The main point is DO NOT ARGUE over formatting. There are tons of tools to automate this. Use one! It's a waste of time and money for engineers to argue over formatting. For things that don't fall under the purview of automatic formatting (indentation, tabs vs. spaces, double vs. single quotes, etc.) look here for some guidance.","title":"Formatting"},{"location":"style-guide/#use-consistent-capitalization","text":"JavaScript is untyped, so capitalization tells you a lot about your variables, functions, etc. These rules are subjective, so your team can choose whatever they want. The point is, no matter what you all choose, just be consistent. Bad const DAYS_IN_WEEK = 7 ; const daysInMonth = 30 ; const songs = [ \"Back In Black\" , \"Stairway to Heaven\" , \"Hey Jude\" ]; const Artists = [ \"ACDC\" , \"Led Zeppelin\" , \"The Beatles\" ]; function eraseDatabase () {} function restore_database () {} class animal {} class Alpaca {} Good const DAYS_IN_WEEK = 7 ; const DAYS_IN_MONTH = 30 ; const SONGS = [ \"Back In Black\" , \"Stairway to Heaven\" , \"Hey Jude\" ]; const ARTISTS = [ \"ACDC\" , \"Led Zeppelin\" , \"The Beatles\" ]; function eraseDatabase () {} function restoreDatabase () {} class Animal {} class Alpaca {}","title":"Use consistent capitalization"},{"location":"style-guide/#function-callers-and-callees-should-be-close","text":"If a function calls another, keep those functions vertically close in the source file. Ideally, keep the caller right above the callee. We tend to read code from top-to-bottom, like a newspaper. Because of this, make your code read that way. Bad class PerformanceReview { constructor ( employee ) { this . employee = employee ; } lookupPeers () { return db . lookup ( this . employee , \"peers\" ); } lookupManager () { return db . lookup ( this . employee , \"manager\" ); } getPeerReviews () { const peers = this . lookupPeers (); // ... } perfReview () { this . getPeerReviews (); this . getManagerReview (); this . getSelfReview (); } getManagerReview () { const manager = this . lookupManager (); } getSelfReview () { // ... } } const review = new PerformanceReview ( employee ); review . perfReview (); Good class PerformanceReview { constructor ( employee ) { this . employee = employee ; } perfReview () { this . getPeerReviews (); this . getManagerReview (); this . getSelfReview (); } getPeerReviews () { const peers = this . lookupPeers (); // ... } lookupPeers () { return db . lookup ( this . employee , \"peers\" ); } getManagerReview () { const manager = this . lookupManager (); } lookupManager () { return db . lookup ( this . employee , \"manager\" ); } getSelfReview () { // ... } } const review = new PerformanceReview ( employee ); review . perfReview ();","title":"Function callers and callees should be close"},{"location":"style-guide/#comments","text":"","title":"Comments"},{"location":"style-guide/#only-comment-things-that-have-business-logic-complexity","text":"Comments are an apology, not a requirement. Good code mostly documents itself. Bad function hashIt ( data ) { // The hash let hash = 0 ; // Length of string const length = data . length ; // Loop through every character in data for ( let i = 0 ; i < length ; i ++ ) { // Get character code. const char = data . charCodeAt ( i ); // Make the hash hash = ( hash << 5 ) - hash + char ; // Convert to 32-bit integer hash &= hash ; } } Good function hashIt ( data ) { let hash = 0 ; const length = data . length ; for ( let i = 0 ; i < length ; i ++ ) { const char = data . charCodeAt ( i ); hash = ( hash << 5 ) - hash + char ; // Convert to 32-bit integer hash &= hash ; } }","title":"Only comment things that have business logic complexity"},{"location":"style-guide/#dont-leave-commented-out-code-in-your-codebase","text":"Version control exists for a reason. Leave old code in your history. Bad doStuff (); // doOtherStuff(); // doSomeMoreStuff(); // doSoMuchStuff(); Good doStuff ();","title":"Don't leave commented out code in your codebase"},{"location":"style-guide/#dont-have-journal-comments","text":"Remember, use version control! There's no need for dead code, commented code, and especially journal comments. Use git log to get history! Bad /** * 2016-12-20: Removed monads, didn't understand them (RM) * 2016-10-01: Improved using special monads (JP) * 2016-02-03: Removed type-checking (LI) * 2015-03-14: Added combine with type-checking (JR) */ function combine ( a , b ) { return a + b ; } Good function combine ( a , b ) { return a + b ; }","title":"Don't have journal comments"},{"location":"style-guide/#avoid-positional-markers","text":"They usually just add noise. Let the functions and variable names along with the proper indentation and formatting give the visual structure to your code. Bad //////////////////////////////////////////////////////////////////////////////// // Scope Model Instantiation //////////////////////////////////////////////////////////////////////////////// $scope . model = { menu : \"foo\" , nav : \"bar\" }; //////////////////////////////////////////////////////////////////////////////// // Action setup //////////////////////////////////////////////////////////////////////////////// const actions = function () { // ... }; Good $scope . model = { menu : \"foo\" , nav : \"bar\" }; const actions = function () { // ... };","title":"Avoid positional markers"},{"location":"style-guide/classes/","text":"Introduction Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages. Naming Class names are written in UpperCamelCase. Class names are typically nouns or noun phrases. For example, Character or ImmutableList . Interface names may also be nouns or noun phrases (for example, List ), but may sometimes be adjectives or adjective phrases instead (for example, Readable ). There are no specific rules or even well-established conventions for naming annotation types. Test classes are named starting with the name of the class they are testing, and ending with Test . For example, HashTest or HashIntegrationTest . Bad my_crappy_class MY_CRAPPY_CLASS TestingFunctions Good PlayableCharacter ControllerTest Car Prefer ES2015/ES6 classes over ES5 plain functions It's very difficult to get readable class inheritance, construction, and method definitions for classical ES5 classes. If you need inheritance (and be aware that you might not), then prefer ES2015/ES6 classes. However, prefer small functions over classes until you find yourself needing larger and more complex objects. Bad const Animal = function ( age ) { if ( ! ( this instanceof Animal )) { throw new Error ( \"Instantiate Animal with `new`\" ); } this . age = age ; }; Animal . prototype . move = function move () {}; const Mammal = function ( age , furColor ) { if ( ! ( this instanceof Mammal )) { throw new Error ( \"Instantiate Mammal with `new`\" ); } Animal . call ( this , age ); this . furColor = furColor ; }; Mammal . prototype = Object . create ( Animal . prototype ); Mammal . prototype . constructor = Mammal ; Mammal . prototype . liveBirth = function liveBirth () {}; const Human = function ( age , furColor , languageSpoken ) { if ( ! ( this instanceof Human )) { throw new Error ( \"Instantiate Human with `new`\" ); } Mammal . call ( this , age , furColor ); this . languageSpoken = languageSpoken ; }; Human . prototype = Object . create ( Mammal . prototype ); Human . prototype . constructor = Human ; Human . prototype . speak = function speak () {}; Good class Animal { constructor ( age ) { this . age = age ; } move () { /* ... */ } } class Mammal extends Animal { constructor ( age , furColor ) { super ( age ); this . furColor = furColor ; } liveBirth () { /* ... */ } } class Human extends Mammal { constructor ( age , furColor , languageSpoken ) { super ( age , furColor ); this . languageSpoken = languageSpoken ; } speak () { /* ... */ } } Use method chaining This pattern is very useful in JavaScript and you see it in many libraries such as jQuery and Lodash. It allows your code to be expressive, and less verbose. For that reason, I say, use method chaining and take a look at how clean your code will be. In your class functions, simply return this at the end of every function, and you can chain further class methods onto it. Bad class Car { constructor ( make , model , color ) { this . make = make ; this . model = model ; this . color = color ; } setMake ( make ) { this . make = make ; } setModel ( model ) { this . model = model ; } setColor ( color ) { this . color = color ; } save () { console . log ( this . make , this . model , this . color ); } } const car = new Car ( \"Ford\" , \"F-150\" , \"red\" ); car . setColor ( \"pink\" ); car . save (); Good class Car { constructor ( make , model , color ) { this . make = make ; this . model = model ; this . color = color ; } setMake ( make ) { this . make = make ; // NOTE: Returning this for chaining return this ; } setModel ( model ) { this . model = model ; // NOTE: Returning this for chaining return this ; } setColor ( color ) { this . color = color ; // NOTE: Returning this for chaining return this ; } save () { console . log ( this . make , this . model , this . color ); // NOTE: Returning this for chaining return this ; } } const car = new Car ( \"Ford\" , \"F-150\" , \"red\" ). setColor ( \"pink\" ). save (); Prefer composition over inheritance As stated famously in Design Patterns by the Gang of Four, you should prefer composition over inheritance where you can. There are lots of good reasons to use inheritance and lots of good reasons to use composition. The main point for this maxim is that if your mind instinctively goes for inheritance, try to think if composition could model your problem better. In some cases it can. You might be wondering then, \"when should I use inheritance?\" It depends on your problem at hand, but this is a decent list of when inheritance makes more sense than composition: Your inheritance represents an \"is-a\" relationship and not a \"has-a\" relationship (Human->Animal vs. User->UserDetails). You can reuse code from the base classes (Humans can move like all animals). You want to make global changes to derived classes by changing a base class. (Change the caloric expenditure of all animals when they move). Bad class Employee { constructor ( name , email ) { this . name = name ; this . email = email ; } // ... } // Bad because Employees \"have\" tax data. EmployeeTaxData is not a type of Employee class EmployeeTaxData extends Employee { constructor ( ssn , salary ) { super (); this . ssn = ssn ; this . salary = salary ; } // ... } Good class EmployeeTaxData { constructor ( ssn , salary ) { this . ssn = ssn ; this . salary = salary ; } // ... } class Employee { constructor ( name , email ) { this . name = name ; this . email = email ; } setTaxData ( ssn , salary ) { this . taxData = new EmployeeTaxData ( ssn , salary ); } // ... }","title":"Classes"},{"location":"style-guide/classes/#introduction","text":"Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages.","title":"Introduction"},{"location":"style-guide/classes/#naming","text":"Class names are written in UpperCamelCase. Class names are typically nouns or noun phrases. For example, Character or ImmutableList . Interface names may also be nouns or noun phrases (for example, List ), but may sometimes be adjectives or adjective phrases instead (for example, Readable ). There are no specific rules or even well-established conventions for naming annotation types. Test classes are named starting with the name of the class they are testing, and ending with Test . For example, HashTest or HashIntegrationTest . Bad my_crappy_class MY_CRAPPY_CLASS TestingFunctions Good PlayableCharacter ControllerTest Car","title":"Naming"},{"location":"style-guide/classes/#prefer-es2015es6-classes-over-es5-plain-functions","text":"It's very difficult to get readable class inheritance, construction, and method definitions for classical ES5 classes. If you need inheritance (and be aware that you might not), then prefer ES2015/ES6 classes. However, prefer small functions over classes until you find yourself needing larger and more complex objects. Bad const Animal = function ( age ) { if ( ! ( this instanceof Animal )) { throw new Error ( \"Instantiate Animal with `new`\" ); } this . age = age ; }; Animal . prototype . move = function move () {}; const Mammal = function ( age , furColor ) { if ( ! ( this instanceof Mammal )) { throw new Error ( \"Instantiate Mammal with `new`\" ); } Animal . call ( this , age ); this . furColor = furColor ; }; Mammal . prototype = Object . create ( Animal . prototype ); Mammal . prototype . constructor = Mammal ; Mammal . prototype . liveBirth = function liveBirth () {}; const Human = function ( age , furColor , languageSpoken ) { if ( ! ( this instanceof Human )) { throw new Error ( \"Instantiate Human with `new`\" ); } Mammal . call ( this , age , furColor ); this . languageSpoken = languageSpoken ; }; Human . prototype = Object . create ( Mammal . prototype ); Human . prototype . constructor = Human ; Human . prototype . speak = function speak () {}; Good class Animal { constructor ( age ) { this . age = age ; } move () { /* ... */ } } class Mammal extends Animal { constructor ( age , furColor ) { super ( age ); this . furColor = furColor ; } liveBirth () { /* ... */ } } class Human extends Mammal { constructor ( age , furColor , languageSpoken ) { super ( age , furColor ); this . languageSpoken = languageSpoken ; } speak () { /* ... */ } }","title":"Prefer ES2015/ES6 classes over ES5 plain functions"},{"location":"style-guide/classes/#use-method-chaining","text":"This pattern is very useful in JavaScript and you see it in many libraries such as jQuery and Lodash. It allows your code to be expressive, and less verbose. For that reason, I say, use method chaining and take a look at how clean your code will be. In your class functions, simply return this at the end of every function, and you can chain further class methods onto it. Bad class Car { constructor ( make , model , color ) { this . make = make ; this . model = model ; this . color = color ; } setMake ( make ) { this . make = make ; } setModel ( model ) { this . model = model ; } setColor ( color ) { this . color = color ; } save () { console . log ( this . make , this . model , this . color ); } } const car = new Car ( \"Ford\" , \"F-150\" , \"red\" ); car . setColor ( \"pink\" ); car . save (); Good class Car { constructor ( make , model , color ) { this . make = make ; this . model = model ; this . color = color ; } setMake ( make ) { this . make = make ; // NOTE: Returning this for chaining return this ; } setModel ( model ) { this . model = model ; // NOTE: Returning this for chaining return this ; } setColor ( color ) { this . color = color ; // NOTE: Returning this for chaining return this ; } save () { console . log ( this . make , this . model , this . color ); // NOTE: Returning this for chaining return this ; } } const car = new Car ( \"Ford\" , \"F-150\" , \"red\" ). setColor ( \"pink\" ). save ();","title":"Use method chaining"},{"location":"style-guide/classes/#prefer-composition-over-inheritance","text":"As stated famously in Design Patterns by the Gang of Four, you should prefer composition over inheritance where you can. There are lots of good reasons to use inheritance and lots of good reasons to use composition. The main point for this maxim is that if your mind instinctively goes for inheritance, try to think if composition could model your problem better. In some cases it can. You might be wondering then, \"when should I use inheritance?\" It depends on your problem at hand, but this is a decent list of when inheritance makes more sense than composition: Your inheritance represents an \"is-a\" relationship and not a \"has-a\" relationship (Human->Animal vs. User->UserDetails). You can reuse code from the base classes (Humans can move like all animals). You want to make global changes to derived classes by changing a base class. (Change the caloric expenditure of all animals when they move). Bad class Employee { constructor ( name , email ) { this . name = name ; this . email = email ; } // ... } // Bad because Employees \"have\" tax data. EmployeeTaxData is not a type of Employee class EmployeeTaxData extends Employee { constructor ( ssn , salary ) { super (); this . ssn = ssn ; this . salary = salary ; } // ... } Good class EmployeeTaxData { constructor ( ssn , salary ) { this . ssn = ssn ; this . salary = salary ; } // ... } class Employee { constructor ( name , email ) { this . name = name ; this . email = email ; } setTaxData ( ssn , salary ) { this . taxData = new EmployeeTaxData ( ssn , salary ); } // ... }","title":"Prefer composition over inheritance"},{"location":"style-guide/functions/","text":"Introduction Functions should be easily readable, reusable, and refactorable. Functions should only perform one thing to make it easier to test and break big problems down into tiny solutions that work together to solve the problem. Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages. Naming Identifers use only ASCII letters and digits and in a small number of cases, noted below, underscores. Special prefixes or suffixes are not used. For example, name_ , mName , function_name , and kName . Functions and methods are written in lowerCamelCase. The names should typically be verbs like sendMessage or stopTransaction . Caution Underscores may appear in test names to separate logical components of the name, with each component written in lowerCamelCase. One typical pattern is <functionUnderTest>_<state> like pop_emptyStack . Bad myFunction (...); My_exciting_function (...); SET_VARIABLE (...); Good getCreditCardNumber (...); setAppointmentTime (...); calculateAreaOfBackyard (...); Whitespace A single blank line should be used: Between consecutive functions and other variables. As required by other sections of this document. A single blank line may also appear anywhere it improves readability, for example between statements to organize the code into logical subsections. A blank line before the first member or initializer, or after the last member or initializer of the class, is neither encouraged nor discouraged. Multiple consecutive blank lines are permitted, but never required (or encouraged). Beyond where required by the language or other style rules, and apart from literals, and comments, a single ASCII space also appears in the following places: Separating the function's open curly brace ( { ) and closing parenthesis ( ) ) that precedes it on that line. Places that should avoid spaces: Never put a space between the function name and the open parenthesis ( ( ) Open curly brace ( { ) is on the same line as the function name Bad getCreditCardNumber ( user ) { //... } nextFunction ( progressReport ) { } Good setAppointmentTime ( time ) { //... } calculateAreaOfBackyard ( width , height ) { //... } Function arguments (2 or fewer ideally) Limiting the amount of function parameters is incredibly important because it makes testing your function easier. Having more than three leads to a combinatorial explosion where you have to test tons of different cases with each separate argument. One or two arguments is the ideal case, and three should be avoided if possible. Anything more than that should be consolidated. Usually, if you have more than two arguments then your function is trying to do too much. In cases where it's not, most of the time a higher-level object will suffice as an argument. Since JavaScript allows you to make objects on the fly, without a lot of class boilerplate, you can use an object if you are finding yourself needing a lot of arguments. To make it obvious what properties the function expects, you can use the ES2015/ES6 destructuring syntax. This has a few advantages: When someone looks at the function signature, it's immediately clear what properties are being used. Destructuring also clones the specified primitive values of the argument object passed into the function. This can help prevent side effects. Note: objects and arrays that are destructured from the argument object are NOT cloned. Linters can warn you about unused properties, which would be impossible without destructuring. Bad function createMenu ( title , body , buttonText , cancellable ) { // ... } Good function createMenu ({ title , body , buttonText , cancellable }) { // ... } createMenu ({ title : \"Foo\" , body : \"Bar\" , buttonText : \"Baz\" , cancellable : true }); Functions should do one thing This is by far the most important rule in software engineering. When functions do more than one thing, they are harder to compose, test, and reason about. When you can isolate a function to just one action, they can be refactored easily and your code will read much cleaner. If you take nothing else away from this guide other than this, you'll be ahead of many developers. Bad function emailClients ( clients ) { clients . forEach ( client => { const clientRecord = database . lookup ( client ); if ( clientRecord . isActive ()) { email ( client ); } }); } Good function emailActiveClients ( clients ) { clients . filter ( isActiveClient ). forEach ( email ); } function isActiveClient ( client ) { const clientRecord = database . lookup ( client ); return clientRecord . isActive (); } Function names should say what they do Bad function addToDate ( date , month ) { // ... } const date = new Date (); // It's hard to tell from the function name what is added addToDate ( date , 1 ); Good function addMonthToDate ( month , date ) { // ... } const date = new Date (); addMonthToDate ( 1 , date ); Functions should only be one level of abstraction When you have more than one level of abstraction your function is usually doing too much. Splitting up functions leads to reusability and easier testing. Bad function parseBetterJSAlternative ( code ) { const REGEXES = [ // ... ]; const statements = code . split ( \" \" ); const tokens = []; REGEXES . forEach ( REGEX => { statements . forEach ( statement => { // ... }); }); const ast = []; tokens . forEach ( token => { // lex... }); ast . forEach ( node => { // parse... }); } Good function parseBetterJSAlternative ( code ) { const tokens = tokenize ( code ); const syntaxTree = parse ( tokens ); syntaxTree . forEach ( node => { // parse... }); } function tokenize ( code ) { const REGEXES = [ // ... ]; const statements = code . split ( \" \" ); const tokens = []; REGEXES . forEach ( REGEX => { statements . forEach ( statement => { tokens . push ( /* ... */ ); }); }); return tokens ; } function parse ( tokens ) { const syntaxTree = []; tokens . forEach ( token => { syntaxTree . push ( /* ... */ ); }); return syntaxTree ; } Remove duplicate code Do your absolute best to avoid duplicate code. Duplicate code is bad because it means that there's more than one place to alter something if you need to change some logic. Imagine if you run a restaurant and you keep track of your inventory: all your tomatoes, onions, garlic, spices, etc. If you have multiple lists that you keep this on, then all have to be updated when you serve a dish with tomatoes in them. If you only have one list, there's only one place to update! Oftentimes you have duplicate code because you have two or more slightly different things, that share a lot in common, but their differences force you to have two or more separate functions that do much of the same things. Removing duplicate code means creating an abstraction that can handle this set of different things with just one function/module/class. Getting the abstraction right is critical, that's why you should follow the SOLID principles laid out in the Classes section. Bad abstractions can be worse than duplicate code, so be careful! Having said this, if you can make a good abstraction, do it! Don't repeat yourself, otherwise you'll find yourself updating multiple places anytime you want to change one thing. Bad function showDeveloperList ( developers ) { developers . forEach ( developer => { const expectedSalary = developer . calculateExpectedSalary (); const experience = developer . getExperience (); const githubLink = developer . getGithubLink (); const data = { expectedSalary , experience , githubLink }; render ( data ); }); } function showManagerList ( managers ) { managers . forEach ( manager => { const expectedSalary = manager . calculateExpectedSalary (); const experience = manager . getExperience (); const portfolio = manager . getMBAProjects (); const data = { expectedSalary , experience , portfolio }; render ( data ); }); } Good function showEmployeeList ( employees ) { employees . forEach ( employee => { const expectedSalary = employee . calculateExpectedSalary (); const experience = employee . getExperience (); const data = { expectedSalary , experience }; switch ( employee . type ) { case \"manager\" : data . portfolio = employee . getMBAProjects (); break ; case \"developer\" : data . githubLink = employee . getGithubLink (); break ; } render ( data ); }); } Set default objects Bad const menuConfig = { title : null , body : \"Bar\" , buttonText : null , cancellable : true }; function createMenu ( config ) { config . title = config . title || \"Foo\" ; config . body = config . body || \"Bar\" ; config . buttonText = config . buttonText || \"Baz\" ; config . cancellable = config . cancellable !== undefined ? config . cancellable : true ; } createMenu ( menuConfig ); Good const menuConfig = { title : \"Order\" , // User did not include 'body' key buttonText : \"Send\" , cancellable : true }; function createMenu ( config ) { config = Object . assign ( { title : \"Foo\" , body : \"Bar\" , buttonText : \"Baz\" , cancellable : true }, config ); // config now equals: {title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true} // ... } createMenu ( menuConfig ); Don't use flags as function parameters Flags tell your user that this function does more than one thing. Functions should do one thing. Split out your functions if they are following different code paths based on a boolean. Bad function createFile ( name , temp ) { if ( temp ) { fs . create ( `./temp/ ${ name } ` ); } else { fs . create ( name ); } } Good function createFile ( name ) { fs . create ( name ); } function createTempFile ( name ) { createFile ( `./temp/ ${ name } ` ); } Avoid Side Effects Part 1 A function produces a side effect if it does anything other than take a value in and return another value or values. A side effect could be writing to a file, modifying some global variable, or accidentally wiring all your money to a stranger. Now, you do need to have side effects in a program on occasion. Like the previous example, you might need to write to a file. What you want to do is to centralize where you are doing this. Don't have several functions and classes that write to a particular file. Have one service that does it. One and only one. The main point is to avoid common pitfalls like sharing state between objects without any structure, using mutable data types that can be written to by anything, and not centralizing where your side effects occur. If you can do this, you will be happier than the vast majority of other programmers. Bad // Global variable referenced by following function. // If we had another function that used this name, now it'd be an array and it could break it. let name = \"Ryan McDermott\" ; function splitIntoFirstAndLastName () { name = name . split ( \" \" ); } splitIntoFirstAndLastName (); console . log ( name ); // ['Ryan', 'McDermott']; Good function splitIntoFirstAndLastName ( name ) { return name . split ( \" \" ); } const name = \"Ryan McDermott\" ; const newName = splitIntoFirstAndLastName ( name ); console . log ( name ); // 'Ryan McDermott'; console . log ( newName ); // ['Ryan', 'McDermott']; Part 2 In JavaScript, primitives are passed by value and objects/arrays are passed by reference. In the case of objects and arrays, if your function makes a change in a shopping cart array, for example, by adding an item to purchase, then any other function that uses that cart array will be affected by this addition. That may be great, however it can be bad too. Let's imagine a bad situation: The user clicks the \"Purchase\", button which calls a purchase function that spawns a network request and sends the cart array to the server. Because of a bad network connection, the purchase function has to keep retrying the request. Now, what if in the meantime the user accidentally clicks \"Add to Cart\" button on an item they don't actually want before the network request begins? If that happens and the network request begins, then that purchase function will send the accidentally added item because it has a reference to a shopping cart array that the addItemToCart function modified by adding an unwanted item. A great solution would be for the addItemToCart to always clone the cart , edit it, and return the clone. This ensures that no other functions that are holding onto a reference of the shopping cart will be affected by any changes. Two caveats to mention to this approach: There might be cases where you actually want to modify the input object, but when you adopt this programming practice you will find that those cases are pretty rare. Most things can be refactored to have no side effects! Cloning big objects can be very expensive in terms of performance. Luckily, this isn't a big issue in practice because there are great libraries that allow this kind of programming approach to be fast and not as memory intensive as it would be for you to manually clone objects and arrays. Bad const addItemToCart = ( cart , item ) => { cart . push ({ item , date : Date . now () }); }; Good const addItemToCart = ( cart , item ) => { return [... cart , { item , date : Date . now () }]; }; Don't write to global functions Polluting globals is a bad practice in JavaScript because you could clash with another library and the user of your API would be none-the-wiser until they get an exception in production. Let's think about an example: what if you wanted to extend JavaScript's native Array method to have a diff method that could show the difference between two arrays? You could write your new function to the Array.prototype , but it could clash with another library that tried to do the same thing. What if that other library was just using diff to find the difference between the first and last elements of an array? This is why it would be much better to just use ES2015/ES6 classes and simply extend the Array global. Bad Array . prototype . diff = function diff ( comparisonArray ) { const hash = new Set ( comparisonArray ); return this . filter ( elem => ! hash . has ( elem )); }; Good class SuperArray extends Array { diff ( comparisonArray ) { const hash = new Set ( comparisonArray ); return this . filter ( elem => ! hash . has ( elem )); } } Favor functional programming over imperative programming JavaScript isn't a functional language in the way that Haskell is, but it has a functional flavor to it. Functional languages can be cleaner and easier to test. Favor this style of programming when you can. Bad const programmerOutput = [ { name : \"Uncle Bobby\" , linesOfCode : 500 }, { name : \"Suzie Q\" , linesOfCode : 1500 }, { name : \"Jimmy Gosling\" , linesOfCode : 150 }, { name : \"Gracie Hopper\" , linesOfCode : 1000 } ]; let totalOutput = 0 ; for ( let i = 0 ; i < programmerOutput . length ; i ++ ) { totalOutput += programmerOutput [ i ]. linesOfCode ; } ``` Good const programmerOutput = [ { name : \"Uncle Bobby\" , linesOfCode : 500 }, { name : \"Suzie Q\" , linesOfCode : 1500 }, { name : \"Jimmy Gosling\" , linesOfCode : 150 }, { name : \"Gracie Hopper\" , linesOfCode : 1000 } ]; const totalOutput = programmerOutput . reduce ( ( totalLines , output ) => totalLines + output . linesOfCode , 0 ); Encapsulate conditionals Bad if ( fsm . state === \"fetching\" && isEmpty ( listNode )) { // ... } Good function shouldShowSpinner ( fsm , listNode ) { return fsm . state === \"fetching\" && isEmpty ( listNode ); } if ( shouldShowSpinner ( fsmInstance , listNodeInstance )) { // ... } Avoid negative conditionals Bad function isDOMNodeNotPresent ( node ) { // ... } if ( ! isDOMNodeNotPresent ( node )) { // ... } Good function isDOMNodePresent ( node ) { // ... } if ( isDOMNodePresent ( node )) { // ... } Avoid conditionals This seems like an impossible task. Upon first hearing this, most people say, \"how am I supposed to do anything without an if statement?\" The answer is that you can use polymorphism to achieve the same task in many cases. The second question is usually, \"well that's great but why would I want to do that?\" The answer is a previous clean code concept we learned: a function should only do one thing. When you have classes and functions that have if statements, you are telling your user that your function does more than one thing. Remember, just do one thing. Bad class Airplane { // ... getCruisingAltitude () { switch ( this . type ) { case \"777\" : return this . getMaxAltitude () - this . getPassengerCount (); case \"Air Force One\" : return this . getMaxAltitude (); case \"Cessna\" : return this . getMaxAltitude () - this . getFuelExpenditure (); } } } Good class Airplane { // ... } class Boeing777 extends Airplane { // ... getCruisingAltitude () { return this . getMaxAltitude () - this . getPassengerCount (); } } class AirForceOne extends Airplane { // ... getCruisingAltitude () { return this . getMaxAltitude (); } } class Cessna extends Airplane { // ... getCruisingAltitude () { return this . getMaxAltitude () - this . getFuelExpenditure (); } } Avoid type-checking Question This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Does this violate secure coding principles? Part 1 JavaScript is untyped, which means your functions can take any type of argument. Sometimes you are bitten by this freedom and it becomes tempting to do type-checking in your functions. There are many ways to avoid having to do this. The first thing to consider is consistent APIs. Bad function travelToTexas ( vehicle ) { if ( vehicle instanceof Bicycle ) { vehicle . pedal ( this . currentLocation , new Location ( \"texas\" )); } else if ( vehicle instanceof Car ) { vehicle . drive ( this . currentLocation , new Location ( \"texas\" )); } } Good function travelToTexas ( vehicle ) { vehicle . move ( this . currentLocation , new Location ( \"texas\" )); } Part 2 If you are working with basic primitive values like strings and integers, and you can't use polymorphism but you still feel the need to type-check, you should consider using TypeScript. It is an excellent alternative to normal JavaScript, as it provides you with static typing on top of standard JavaScript syntax. The problem with manually type-checking normal JavaScript is that doing it well requires so much extra verbiage that the faux \"type-safety\" you get doesn't make up for the lost readability. Keep your JavaScript clean, write good tests, and have good code reviews. Otherwise, do all of that but with TypeScript (which, like I said, is a great alternative!). Bad function combine ( val1 , val2 ) { if ( ( typeof val1 === \"number\" && typeof val2 === \"number\" ) || ( typeof val1 === \"string\" && typeof val2 === \"string\" ) ) { return val1 + val2 ; } throw new Error ( \"Must be of type String or Number\" ); } Good function combine ( val1 , val2 ) { return val1 + val2 ; } Don't over-optimize Modern browsers do a lot of optimization under-the-hood at runtime. A lot of times, if you are optimizing then you are just wasting your time. There are good resources for seeing where optimization is lacking. Target those in the meantime, until they are fixed if they can be. Bad // On old browsers, each iteration with uncached `list.length` would be costly // because of `list.length` recomputation. In modern browsers, this is optimized. for ( let i = 0 , len = list . length ; i < len ; i ++ ) { // ... } Good for ( let i = 0 ; i < list . length ; i ++ ) { // ... } Remove dead code Dead code is just as bad as duplicate code. There's no reason to keep it in your codebase. If it's not being called, get rid of it! It will still be safe in your version history if you still need it. Bad function oldRequestModule ( url ) { // ... } function newRequestModule ( url ) { // ... } const req = newRequestModule ; inventoryTracker ( \"apples\" , req , \"www.inventory-awesome.io\" ); Good function newRequestModule ( url ) { // ... } const req = newRequestModule ; inventoryTracker ( \"apples\" , req , \"www.inventory-awesome.io\" );","title":"Functions"},{"location":"style-guide/functions/#introduction","text":"Functions should be easily readable, reusable, and refactorable. Functions should only perform one thing to make it easier to test and break big problems down into tiny solutions that work together to solve the problem. Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages.","title":"Introduction"},{"location":"style-guide/functions/#naming","text":"Identifers use only ASCII letters and digits and in a small number of cases, noted below, underscores. Special prefixes or suffixes are not used. For example, name_ , mName , function_name , and kName . Functions and methods are written in lowerCamelCase. The names should typically be verbs like sendMessage or stopTransaction . Caution Underscores may appear in test names to separate logical components of the name, with each component written in lowerCamelCase. One typical pattern is <functionUnderTest>_<state> like pop_emptyStack . Bad myFunction (...); My_exciting_function (...); SET_VARIABLE (...); Good getCreditCardNumber (...); setAppointmentTime (...); calculateAreaOfBackyard (...);","title":"Naming"},{"location":"style-guide/functions/#whitespace","text":"A single blank line should be used: Between consecutive functions and other variables. As required by other sections of this document. A single blank line may also appear anywhere it improves readability, for example between statements to organize the code into logical subsections. A blank line before the first member or initializer, or after the last member or initializer of the class, is neither encouraged nor discouraged. Multiple consecutive blank lines are permitted, but never required (or encouraged). Beyond where required by the language or other style rules, and apart from literals, and comments, a single ASCII space also appears in the following places: Separating the function's open curly brace ( { ) and closing parenthesis ( ) ) that precedes it on that line. Places that should avoid spaces: Never put a space between the function name and the open parenthesis ( ( ) Open curly brace ( { ) is on the same line as the function name Bad getCreditCardNumber ( user ) { //... } nextFunction ( progressReport ) { } Good setAppointmentTime ( time ) { //... } calculateAreaOfBackyard ( width , height ) { //... }","title":"Whitespace"},{"location":"style-guide/functions/#function-arguments-2-or-fewer-ideally","text":"Limiting the amount of function parameters is incredibly important because it makes testing your function easier. Having more than three leads to a combinatorial explosion where you have to test tons of different cases with each separate argument. One or two arguments is the ideal case, and three should be avoided if possible. Anything more than that should be consolidated. Usually, if you have more than two arguments then your function is trying to do too much. In cases where it's not, most of the time a higher-level object will suffice as an argument. Since JavaScript allows you to make objects on the fly, without a lot of class boilerplate, you can use an object if you are finding yourself needing a lot of arguments. To make it obvious what properties the function expects, you can use the ES2015/ES6 destructuring syntax. This has a few advantages: When someone looks at the function signature, it's immediately clear what properties are being used. Destructuring also clones the specified primitive values of the argument object passed into the function. This can help prevent side effects. Note: objects and arrays that are destructured from the argument object are NOT cloned. Linters can warn you about unused properties, which would be impossible without destructuring. Bad function createMenu ( title , body , buttonText , cancellable ) { // ... } Good function createMenu ({ title , body , buttonText , cancellable }) { // ... } createMenu ({ title : \"Foo\" , body : \"Bar\" , buttonText : \"Baz\" , cancellable : true });","title":"Function arguments (2 or fewer ideally)"},{"location":"style-guide/functions/#functions-should-do-one-thing","text":"This is by far the most important rule in software engineering. When functions do more than one thing, they are harder to compose, test, and reason about. When you can isolate a function to just one action, they can be refactored easily and your code will read much cleaner. If you take nothing else away from this guide other than this, you'll be ahead of many developers. Bad function emailClients ( clients ) { clients . forEach ( client => { const clientRecord = database . lookup ( client ); if ( clientRecord . isActive ()) { email ( client ); } }); } Good function emailActiveClients ( clients ) { clients . filter ( isActiveClient ). forEach ( email ); } function isActiveClient ( client ) { const clientRecord = database . lookup ( client ); return clientRecord . isActive (); }","title":"Functions should do one thing"},{"location":"style-guide/functions/#function-names-should-say-what-they-do","text":"Bad function addToDate ( date , month ) { // ... } const date = new Date (); // It's hard to tell from the function name what is added addToDate ( date , 1 ); Good function addMonthToDate ( month , date ) { // ... } const date = new Date (); addMonthToDate ( 1 , date );","title":"Function names should say what they do"},{"location":"style-guide/functions/#functions-should-only-be-one-level-of-abstraction","text":"When you have more than one level of abstraction your function is usually doing too much. Splitting up functions leads to reusability and easier testing. Bad function parseBetterJSAlternative ( code ) { const REGEXES = [ // ... ]; const statements = code . split ( \" \" ); const tokens = []; REGEXES . forEach ( REGEX => { statements . forEach ( statement => { // ... }); }); const ast = []; tokens . forEach ( token => { // lex... }); ast . forEach ( node => { // parse... }); } Good function parseBetterJSAlternative ( code ) { const tokens = tokenize ( code ); const syntaxTree = parse ( tokens ); syntaxTree . forEach ( node => { // parse... }); } function tokenize ( code ) { const REGEXES = [ // ... ]; const statements = code . split ( \" \" ); const tokens = []; REGEXES . forEach ( REGEX => { statements . forEach ( statement => { tokens . push ( /* ... */ ); }); }); return tokens ; } function parse ( tokens ) { const syntaxTree = []; tokens . forEach ( token => { syntaxTree . push ( /* ... */ ); }); return syntaxTree ; }","title":"Functions should only be one level of abstraction"},{"location":"style-guide/functions/#remove-duplicate-code","text":"Do your absolute best to avoid duplicate code. Duplicate code is bad because it means that there's more than one place to alter something if you need to change some logic. Imagine if you run a restaurant and you keep track of your inventory: all your tomatoes, onions, garlic, spices, etc. If you have multiple lists that you keep this on, then all have to be updated when you serve a dish with tomatoes in them. If you only have one list, there's only one place to update! Oftentimes you have duplicate code because you have two or more slightly different things, that share a lot in common, but their differences force you to have two or more separate functions that do much of the same things. Removing duplicate code means creating an abstraction that can handle this set of different things with just one function/module/class. Getting the abstraction right is critical, that's why you should follow the SOLID principles laid out in the Classes section. Bad abstractions can be worse than duplicate code, so be careful! Having said this, if you can make a good abstraction, do it! Don't repeat yourself, otherwise you'll find yourself updating multiple places anytime you want to change one thing. Bad function showDeveloperList ( developers ) { developers . forEach ( developer => { const expectedSalary = developer . calculateExpectedSalary (); const experience = developer . getExperience (); const githubLink = developer . getGithubLink (); const data = { expectedSalary , experience , githubLink }; render ( data ); }); } function showManagerList ( managers ) { managers . forEach ( manager => { const expectedSalary = manager . calculateExpectedSalary (); const experience = manager . getExperience (); const portfolio = manager . getMBAProjects (); const data = { expectedSalary , experience , portfolio }; render ( data ); }); } Good function showEmployeeList ( employees ) { employees . forEach ( employee => { const expectedSalary = employee . calculateExpectedSalary (); const experience = employee . getExperience (); const data = { expectedSalary , experience }; switch ( employee . type ) { case \"manager\" : data . portfolio = employee . getMBAProjects (); break ; case \"developer\" : data . githubLink = employee . getGithubLink (); break ; } render ( data ); }); }","title":"Remove duplicate code"},{"location":"style-guide/functions/#set-default-objects","text":"Bad const menuConfig = { title : null , body : \"Bar\" , buttonText : null , cancellable : true }; function createMenu ( config ) { config . title = config . title || \"Foo\" ; config . body = config . body || \"Bar\" ; config . buttonText = config . buttonText || \"Baz\" ; config . cancellable = config . cancellable !== undefined ? config . cancellable : true ; } createMenu ( menuConfig ); Good const menuConfig = { title : \"Order\" , // User did not include 'body' key buttonText : \"Send\" , cancellable : true }; function createMenu ( config ) { config = Object . assign ( { title : \"Foo\" , body : \"Bar\" , buttonText : \"Baz\" , cancellable : true }, config ); // config now equals: {title: \"Order\", body: \"Bar\", buttonText: \"Send\", cancellable: true} // ... } createMenu ( menuConfig );","title":"Set default objects"},{"location":"style-guide/functions/#dont-use-flags-as-function-parameters","text":"Flags tell your user that this function does more than one thing. Functions should do one thing. Split out your functions if they are following different code paths based on a boolean. Bad function createFile ( name , temp ) { if ( temp ) { fs . create ( `./temp/ ${ name } ` ); } else { fs . create ( name ); } } Good function createFile ( name ) { fs . create ( name ); } function createTempFile ( name ) { createFile ( `./temp/ ${ name } ` ); }","title":"Don't use flags as function parameters"},{"location":"style-guide/functions/#avoid-side-effects","text":"","title":"Avoid Side Effects"},{"location":"style-guide/functions/#part-1","text":"A function produces a side effect if it does anything other than take a value in and return another value or values. A side effect could be writing to a file, modifying some global variable, or accidentally wiring all your money to a stranger. Now, you do need to have side effects in a program on occasion. Like the previous example, you might need to write to a file. What you want to do is to centralize where you are doing this. Don't have several functions and classes that write to a particular file. Have one service that does it. One and only one. The main point is to avoid common pitfalls like sharing state between objects without any structure, using mutable data types that can be written to by anything, and not centralizing where your side effects occur. If you can do this, you will be happier than the vast majority of other programmers. Bad // Global variable referenced by following function. // If we had another function that used this name, now it'd be an array and it could break it. let name = \"Ryan McDermott\" ; function splitIntoFirstAndLastName () { name = name . split ( \" \" ); } splitIntoFirstAndLastName (); console . log ( name ); // ['Ryan', 'McDermott']; Good function splitIntoFirstAndLastName ( name ) { return name . split ( \" \" ); } const name = \"Ryan McDermott\" ; const newName = splitIntoFirstAndLastName ( name ); console . log ( name ); // 'Ryan McDermott'; console . log ( newName ); // ['Ryan', 'McDermott'];","title":"Part 1"},{"location":"style-guide/functions/#part-2","text":"In JavaScript, primitives are passed by value and objects/arrays are passed by reference. In the case of objects and arrays, if your function makes a change in a shopping cart array, for example, by adding an item to purchase, then any other function that uses that cart array will be affected by this addition. That may be great, however it can be bad too. Let's imagine a bad situation: The user clicks the \"Purchase\", button which calls a purchase function that spawns a network request and sends the cart array to the server. Because of a bad network connection, the purchase function has to keep retrying the request. Now, what if in the meantime the user accidentally clicks \"Add to Cart\" button on an item they don't actually want before the network request begins? If that happens and the network request begins, then that purchase function will send the accidentally added item because it has a reference to a shopping cart array that the addItemToCart function modified by adding an unwanted item. A great solution would be for the addItemToCart to always clone the cart , edit it, and return the clone. This ensures that no other functions that are holding onto a reference of the shopping cart will be affected by any changes. Two caveats to mention to this approach: There might be cases where you actually want to modify the input object, but when you adopt this programming practice you will find that those cases are pretty rare. Most things can be refactored to have no side effects! Cloning big objects can be very expensive in terms of performance. Luckily, this isn't a big issue in practice because there are great libraries that allow this kind of programming approach to be fast and not as memory intensive as it would be for you to manually clone objects and arrays. Bad const addItemToCart = ( cart , item ) => { cart . push ({ item , date : Date . now () }); }; Good const addItemToCart = ( cart , item ) => { return [... cart , { item , date : Date . now () }]; };","title":"Part 2"},{"location":"style-guide/functions/#dont-write-to-global-functions","text":"Polluting globals is a bad practice in JavaScript because you could clash with another library and the user of your API would be none-the-wiser until they get an exception in production. Let's think about an example: what if you wanted to extend JavaScript's native Array method to have a diff method that could show the difference between two arrays? You could write your new function to the Array.prototype , but it could clash with another library that tried to do the same thing. What if that other library was just using diff to find the difference between the first and last elements of an array? This is why it would be much better to just use ES2015/ES6 classes and simply extend the Array global. Bad Array . prototype . diff = function diff ( comparisonArray ) { const hash = new Set ( comparisonArray ); return this . filter ( elem => ! hash . has ( elem )); }; Good class SuperArray extends Array { diff ( comparisonArray ) { const hash = new Set ( comparisonArray ); return this . filter ( elem => ! hash . has ( elem )); } }","title":"Don't write to global functions"},{"location":"style-guide/functions/#favor-functional-programming-over-imperative-programming","text":"JavaScript isn't a functional language in the way that Haskell is, but it has a functional flavor to it. Functional languages can be cleaner and easier to test. Favor this style of programming when you can. Bad const programmerOutput = [ { name : \"Uncle Bobby\" , linesOfCode : 500 }, { name : \"Suzie Q\" , linesOfCode : 1500 }, { name : \"Jimmy Gosling\" , linesOfCode : 150 }, { name : \"Gracie Hopper\" , linesOfCode : 1000 } ]; let totalOutput = 0 ; for ( let i = 0 ; i < programmerOutput . length ; i ++ ) { totalOutput += programmerOutput [ i ]. linesOfCode ; } ``` Good const programmerOutput = [ { name : \"Uncle Bobby\" , linesOfCode : 500 }, { name : \"Suzie Q\" , linesOfCode : 1500 }, { name : \"Jimmy Gosling\" , linesOfCode : 150 }, { name : \"Gracie Hopper\" , linesOfCode : 1000 } ]; const totalOutput = programmerOutput . reduce ( ( totalLines , output ) => totalLines + output . linesOfCode , 0 );","title":"Favor functional programming over imperative programming"},{"location":"style-guide/functions/#encapsulate-conditionals","text":"Bad if ( fsm . state === \"fetching\" && isEmpty ( listNode )) { // ... } Good function shouldShowSpinner ( fsm , listNode ) { return fsm . state === \"fetching\" && isEmpty ( listNode ); } if ( shouldShowSpinner ( fsmInstance , listNodeInstance )) { // ... }","title":"Encapsulate conditionals"},{"location":"style-guide/functions/#avoid-negative-conditionals","text":"Bad function isDOMNodeNotPresent ( node ) { // ... } if ( ! isDOMNodeNotPresent ( node )) { // ... } Good function isDOMNodePresent ( node ) { // ... } if ( isDOMNodePresent ( node )) { // ... }","title":"Avoid negative conditionals"},{"location":"style-guide/functions/#avoid-conditionals","text":"This seems like an impossible task. Upon first hearing this, most people say, \"how am I supposed to do anything without an if statement?\" The answer is that you can use polymorphism to achieve the same task in many cases. The second question is usually, \"well that's great but why would I want to do that?\" The answer is a previous clean code concept we learned: a function should only do one thing. When you have classes and functions that have if statements, you are telling your user that your function does more than one thing. Remember, just do one thing. Bad class Airplane { // ... getCruisingAltitude () { switch ( this . type ) { case \"777\" : return this . getMaxAltitude () - this . getPassengerCount (); case \"Air Force One\" : return this . getMaxAltitude (); case \"Cessna\" : return this . getMaxAltitude () - this . getFuelExpenditure (); } } } Good class Airplane { // ... } class Boeing777 extends Airplane { // ... getCruisingAltitude () { return this . getMaxAltitude () - this . getPassengerCount (); } } class AirForceOne extends Airplane { // ... getCruisingAltitude () { return this . getMaxAltitude (); } } class Cessna extends Airplane { // ... getCruisingAltitude () { return this . getMaxAltitude () - this . getFuelExpenditure (); } }","title":"Avoid conditionals"},{"location":"style-guide/functions/#avoid-type-checking","text":"Question This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Does this violate secure coding principles?","title":"Avoid type-checking"},{"location":"style-guide/functions/#part-1_1","text":"JavaScript is untyped, which means your functions can take any type of argument. Sometimes you are bitten by this freedom and it becomes tempting to do type-checking in your functions. There are many ways to avoid having to do this. The first thing to consider is consistent APIs. Bad function travelToTexas ( vehicle ) { if ( vehicle instanceof Bicycle ) { vehicle . pedal ( this . currentLocation , new Location ( \"texas\" )); } else if ( vehicle instanceof Car ) { vehicle . drive ( this . currentLocation , new Location ( \"texas\" )); } } Good function travelToTexas ( vehicle ) { vehicle . move ( this . currentLocation , new Location ( \"texas\" )); }","title":"Part 1"},{"location":"style-guide/functions/#part-2_1","text":"If you are working with basic primitive values like strings and integers, and you can't use polymorphism but you still feel the need to type-check, you should consider using TypeScript. It is an excellent alternative to normal JavaScript, as it provides you with static typing on top of standard JavaScript syntax. The problem with manually type-checking normal JavaScript is that doing it well requires so much extra verbiage that the faux \"type-safety\" you get doesn't make up for the lost readability. Keep your JavaScript clean, write good tests, and have good code reviews. Otherwise, do all of that but with TypeScript (which, like I said, is a great alternative!). Bad function combine ( val1 , val2 ) { if ( ( typeof val1 === \"number\" && typeof val2 === \"number\" ) || ( typeof val1 === \"string\" && typeof val2 === \"string\" ) ) { return val1 + val2 ; } throw new Error ( \"Must be of type String or Number\" ); } Good function combine ( val1 , val2 ) { return val1 + val2 ; }","title":"Part 2"},{"location":"style-guide/functions/#dont-over-optimize","text":"Modern browsers do a lot of optimization under-the-hood at runtime. A lot of times, if you are optimizing then you are just wasting your time. There are good resources for seeing where optimization is lacking. Target those in the meantime, until they are fixed if they can be. Bad // On old browsers, each iteration with uncached `list.length` would be costly // because of `list.length` recomputation. In modern browsers, this is optimized. for ( let i = 0 , len = list . length ; i < len ; i ++ ) { // ... } Good for ( let i = 0 ; i < list . length ; i ++ ) { // ... }","title":"Don't over-optimize"},{"location":"style-guide/functions/#remove-dead-code","text":"Dead code is just as bad as duplicate code. There's no reason to keep it in your codebase. If it's not being called, get rid of it! It will still be safe in your version history if you still need it. Bad function oldRequestModule ( url ) { // ... } function newRequestModule ( url ) { // ... } const req = newRequestModule ; inventoryTracker ( \"apples\" , req , \"www.inventory-awesome.io\" ); Good function newRequestModule ( url ) { // ... } const req = newRequestModule ; inventoryTracker ( \"apples\" , req , \"www.inventory-awesome.io\" );","title":"Remove dead code"},{"location":"style-guide/objects/","text":"Introduction Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages and this is a good working base to start from. Use getters and setters Using getters and setters to access data on objects could be better than simply looking for a property on an object. \"Why?\" you might ask. Well, here's an unorganized list of reasons why: When you want to do more beyond getting an object property, you don't have to look up and change every accessor in your codebase. Makes adding validation simple when doing a set . Encapsulates the internal representation. Easy to add logging and error handling when getting and setting. You can lazy load your object's properties, let's say getting it from a server. Bad function makeBankAccount () { // ... return { balance : 0 // ... }; } const account = makeBankAccount (); account . balance = 100 ; Good function makeBankAccount () { // this one is private let balance = 0 ; // a \"getter\", made public via the returned object below function getBalance () { return balance ; } // a \"setter\", made public via the returned object below function setBalance ( amount ) { // ... validate before updating the balance balance = amount ; } return { // ... getBalance , setBalance }; } const account = makeBankAccount (); account . setBalance ( 100 ); Make objects have private members This can be accomplished through closures (for ES5 and below). Bad const Employee = function ( name ) { this . name = name ; }; Employee . prototype . getName = function getName () { return this . name ; }; const employee = new Employee ( \"John Doe\" ); console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: John Doe delete employee . name ; console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: undefined Good function makeEmployee ( name ) { return { getName () { return name ; } }; } const employee = makeEmployee ( \"John Doe\" ); console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: John Doe delete employee . name ; console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: John Doe","title":"Objects and Data Structures"},{"location":"style-guide/objects/#introduction","text":"Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages and this is a good working base to start from.","title":"Introduction"},{"location":"style-guide/objects/#use-getters-and-setters","text":"Using getters and setters to access data on objects could be better than simply looking for a property on an object. \"Why?\" you might ask. Well, here's an unorganized list of reasons why: When you want to do more beyond getting an object property, you don't have to look up and change every accessor in your codebase. Makes adding validation simple when doing a set . Encapsulates the internal representation. Easy to add logging and error handling when getting and setting. You can lazy load your object's properties, let's say getting it from a server. Bad function makeBankAccount () { // ... return { balance : 0 // ... }; } const account = makeBankAccount (); account . balance = 100 ; Good function makeBankAccount () { // this one is private let balance = 0 ; // a \"getter\", made public via the returned object below function getBalance () { return balance ; } // a \"setter\", made public via the returned object below function setBalance ( amount ) { // ... validate before updating the balance balance = amount ; } return { // ... getBalance , setBalance }; } const account = makeBankAccount (); account . setBalance ( 100 );","title":"Use getters and setters"},{"location":"style-guide/objects/#make-objects-have-private-members","text":"This can be accomplished through closures (for ES5 and below). Bad const Employee = function ( name ) { this . name = name ; }; Employee . prototype . getName = function getName () { return this . name ; }; const employee = new Employee ( \"John Doe\" ); console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: John Doe delete employee . name ; console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: undefined Good function makeEmployee ( name ) { return { getName () { return name ; } }; } const employee = makeEmployee ( \"John Doe\" ); console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: John Doe delete employee . name ; console . log ( `Employee name: ${ employee . getName () } ` ); // Employee name: John Doe","title":"Make objects have private members"},{"location":"style-guide/variables/","text":"Introduction Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages. Naming Variables use lowerCamelCase and constant names use CONSTANT_CASE. All the rest of the principles below can apply to constants as well as long as they're written in CONSTANT_CASE. Bad Variables Constants CURRENT_DATE var_123 var123 TestThisVar currentDate constant TestThisConst Good Variables Constants currentDate mutableValues blastOffTime streetAddress MAX_NUMBER SPEED_OF_LIGHT GOLDEN_RATIO Warning When naming a variable after an acronym, like ATM, ISP, ID. Only the first letter is still capitalized and the rest are lower. Bad cashLeftInATM newCustomerID Good cashLeftInAtm NewCustomerId Use meaningful and pronounceable names Bad const yyyymmdstr = moment (). format ( \"YYYY/MM/DD\" ); Good const currentDate = moment (). format ( \"YYYY/MM/DD\" ); Use the same vocabulary for the same type of variable Bad getUserInfo (); getClientData (); getCustomerRecord (); Good getUser (); Use searchable names We will read more code than we will ever write. It's important that the code we do write is readable and searchable. By not naming variables that end up being meaningful for understanding our program, we hurt our readers. Make your names searchable. Tools like buddy.js and ESLint can help identify unnamed constants. Bad // What the heck is 86400000 for? setTimeout ( blastOff , 86400000 ); Good // Declare them as capitalized named constants. const MILLISECONDS_IN_A_DAY = 86400000 ; setTimeout ( blastOff , MILLISECONDS_IN_A_DAY ); Use explanatory variables Bad const address = \"One Infinite Loop, Cupertino 95014\" ; const cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/ ; saveCityZipCode ( address . match ( cityZipCodeRegex )[ 1 ], address . match ( cityZipCodeRegex )[ 2 ] ); Good const address = \"One Infinite Loop, Cupertino 95014\" ; const cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/ ; const [, city , zipCode ] = address . match ( cityZipCodeRegex ) || []; saveCityZipCode ( city , zipCode ); Avoid Mental Mapping Explicit is better than implicit. Bad const locations = [ \"Austin\" , \"New York\" , \"San Francisco\" ]; locations . forEach ( `l` => { doStuff (); doSomeOtherStuff (); // ... // ... // ... // Wait, what is `l` for again? dispatch ( l ); }); Good const locations = [ \"Austin\" , \"New York\" , \"San Francisco\" ]; locations . forEach ( location => { doStuff (); doSomeOtherStuff (); // ... // ... // ... dispatch ( location ); }); Don't add unneeded context If your class/object name tells you something, don't repeat that in your variable name. Bad const Car = { carMake : \"Honda\" , carModel : \"Accord\" , carColor : \"Blue\" }; function paintCar ( car ) { car . carColor = \"Red\" ; } Good const Car = { make : \"Honda\" , model : \"Accord\" , color : \"Blue\" }; function paintCar ( car ) { car . color = \"Red\" ; } Use default arguments instead of short circuiting or conditionals Default arguments are often cleaner than short circuiting. Be aware that if you use them, your function will only provide default values for undefined arguments. Other \"falsy\" values such as '' , \"\" , false , null , 0 , and NaN , will not be replaced by a default value. Bad function createMicrobrewery ( name ) { const breweryName = name || \"Hipster Brew Co.\" ; // ... } Good function createMicrobrewery ( name = \"Hipster Brew Co.\" ) { // ... }","title":"Variables"},{"location":"style-guide/variables/#introduction","text":"Info This is based on Ryan McDermott's clean-code-javascript that was written in December 2016. Some of the principles may be very JavaScript specific. Most of the principles will apply to all languages.","title":"Introduction"},{"location":"style-guide/variables/#naming","text":"Variables use lowerCamelCase and constant names use CONSTANT_CASE. All the rest of the principles below can apply to constants as well as long as they're written in CONSTANT_CASE. Bad Variables Constants CURRENT_DATE var_123 var123 TestThisVar currentDate constant TestThisConst Good Variables Constants currentDate mutableValues blastOffTime streetAddress MAX_NUMBER SPEED_OF_LIGHT GOLDEN_RATIO Warning When naming a variable after an acronym, like ATM, ISP, ID. Only the first letter is still capitalized and the rest are lower. Bad cashLeftInATM newCustomerID Good cashLeftInAtm NewCustomerId","title":"Naming"},{"location":"style-guide/variables/#use-meaningful-and-pronounceable-names","text":"Bad const yyyymmdstr = moment (). format ( \"YYYY/MM/DD\" ); Good const currentDate = moment (). format ( \"YYYY/MM/DD\" );","title":"Use meaningful and pronounceable names"},{"location":"style-guide/variables/#use-the-same-vocabulary-for-the-same-type-of-variable","text":"Bad getUserInfo (); getClientData (); getCustomerRecord (); Good getUser ();","title":"Use the same vocabulary for the same type of variable"},{"location":"style-guide/variables/#use-searchable-names","text":"We will read more code than we will ever write. It's important that the code we do write is readable and searchable. By not naming variables that end up being meaningful for understanding our program, we hurt our readers. Make your names searchable. Tools like buddy.js and ESLint can help identify unnamed constants. Bad // What the heck is 86400000 for? setTimeout ( blastOff , 86400000 ); Good // Declare them as capitalized named constants. const MILLISECONDS_IN_A_DAY = 86400000 ; setTimeout ( blastOff , MILLISECONDS_IN_A_DAY );","title":"Use searchable names"},{"location":"style-guide/variables/#use-explanatory-variables","text":"Bad const address = \"One Infinite Loop, Cupertino 95014\" ; const cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/ ; saveCityZipCode ( address . match ( cityZipCodeRegex )[ 1 ], address . match ( cityZipCodeRegex )[ 2 ] ); Good const address = \"One Infinite Loop, Cupertino 95014\" ; const cityZipCodeRegex = /^[^,\\\\]+[,\\\\\\s]+(.+?)\\s*(\\d{5})?$/ ; const [, city , zipCode ] = address . match ( cityZipCodeRegex ) || []; saveCityZipCode ( city , zipCode );","title":"Use explanatory variables"},{"location":"style-guide/variables/#avoid-mental-mapping","text":"Explicit is better than implicit. Bad const locations = [ \"Austin\" , \"New York\" , \"San Francisco\" ]; locations . forEach ( `l` => { doStuff (); doSomeOtherStuff (); // ... // ... // ... // Wait, what is `l` for again? dispatch ( l ); }); Good const locations = [ \"Austin\" , \"New York\" , \"San Francisco\" ]; locations . forEach ( location => { doStuff (); doSomeOtherStuff (); // ... // ... // ... dispatch ( location ); });","title":"Avoid Mental Mapping"},{"location":"style-guide/variables/#dont-add-unneeded-context","text":"If your class/object name tells you something, don't repeat that in your variable name. Bad const Car = { carMake : \"Honda\" , carModel : \"Accord\" , carColor : \"Blue\" }; function paintCar ( car ) { car . carColor = \"Red\" ; } Good const Car = { make : \"Honda\" , model : \"Accord\" , color : \"Blue\" }; function paintCar ( car ) { car . color = \"Red\" ; }","title":"Don't add unneeded context"},{"location":"style-guide/variables/#use-default-arguments-instead-of-short-circuiting-or-conditionals","text":"Default arguments are often cleaner than short circuiting. Be aware that if you use them, your function will only provide default values for undefined arguments. Other \"falsy\" values such as '' , \"\" , false , null , 0 , and NaN , will not be replaced by a default value. Bad function createMicrobrewery ( name ) { const breweryName = name || \"Hipster Brew Co.\" ; // ... } Good function createMicrobrewery ( name = \"Hipster Brew Co.\" ) { // ... }","title":"Use default arguments instead of short circuiting or conditionals"}]}